///<reference path='./debugDraw/nape-debug-draw.d.ts'/>

declare module nape {
    export module callbacks {
        export class Callback {
            public zpp_inner: zpp_nape.callbacks.ZPP_Callback;
            public event: nape.callbacks.CbEvent;
            public listener: nape.callbacks.Listener;
            public toString(): String;
            constructor();
        }
        export class BodyCallback extends nape.callbacks.Callback {
            public body: nape.phys.Body;
            public toString(): String;
            constructor();
        }
        export class Listener {
            public zpp_inner: zpp_nape.callbacks.ZPP_Listener;
            public type: nape.callbacks.ListenerType;
            public event: nape.callbacks.CbEvent;
            public precedence: number;
            public space: nape.space.Space;
            public toString(): String;
            constructor();
        }
        export class BodyListener extends nape.callbacks.Listener {
            public zpp_inner_zn: zpp_nape.callbacks.ZPP_BodyListener;
            public options: nape.callbacks.OptionType;
            public handler: (__0: nape.callbacks.BodyCallback) => void;
            constructor(event: nape.callbacks.CbEvent, options: any, handler: (__0: nape.callbacks.BodyCallback) => void, precedence?: number);
        }
        export class CbEvent {
            public static BEGIN: nape.callbacks.CbEvent;
            public static ONGOING: nape.callbacks.CbEvent;
            public static END: nape.callbacks.CbEvent;
            public static WAKE: nape.callbacks.CbEvent;
            public static SLEEP: nape.callbacks.CbEvent;
            public static BREAK: nape.callbacks.CbEvent;
            public static PRE: nape.callbacks.CbEvent;
            public toString(): String;
            constructor();
        }
        export class CbType {
            public zpp_inner: zpp_nape.callbacks.ZPP_CbType;
            public id: number;
            public userData: any;
            public interactors: nape.phys.InteractorList;
            public constraints: nape.constraint.ConstraintList;
            public static ANY_BODY: nape.callbacks.CbType;
            public static ANY_CONSTRAINT: nape.callbacks.CbType;
            public static ANY_SHAPE: nape.callbacks.CbType;
            public static ANY_COMPOUND: nape.callbacks.CbType;
            public including(includes: any): nape.callbacks.OptionType;
            public excluding(excludes: any): nape.callbacks.OptionType;
            public toString(): String;
            constructor();
        }
        export class CbTypeIterator {
            public zpp_inner: nape.callbacks.CbTypeList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.callbacks.CbTypeIterator;
            public hasNext: () => boolean;
            public next: () => nape.callbacks.CbType;
            public static zpp_pool: nape.callbacks.CbTypeIterator;
            public static get(list: nape.callbacks.CbTypeList): nape.callbacks.CbTypeIterator;
            constructor();
        }
        export class CbTypeList {
            public zpp_inner: zpp_nape.util.ZPP_CbTypeList;
            public length: number;
            public add: (obj: nape.callbacks.CbType) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.callbacks.CbTypeIterator;
            public foreach: (lambda: (__0: nape.callbacks.CbType) => void) => nape.callbacks.CbTypeList;
            public static fromArray(array: any[]): nape.callbacks.CbTypeList;
            public has(obj: nape.callbacks.CbType): boolean;
            public at(index: number): nape.callbacks.CbType;
            public push(obj: nape.callbacks.CbType): boolean;
            public unshift(obj: nape.callbacks.CbType): boolean;
            public pop(): nape.callbacks.CbType;
            public shift(): nape.callbacks.CbType;
            public remove(obj: nape.callbacks.CbType): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.callbacks.CbTypeList;
            public merge(xs: nape.callbacks.CbTypeList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.callbacks.CbType) => boolean): nape.callbacks.CbTypeList;
            constructor();
        }
        export class ConstraintCallback extends nape.callbacks.Callback {
            public constraint: nape.constraint.Constraint;
            public toString(): String;
            constructor();
        }
        export class ConstraintListener extends nape.callbacks.Listener {
            public zpp_inner_zn: zpp_nape.callbacks.ZPP_ConstraintListener;
            public options: nape.callbacks.OptionType;
            public handler: (__0: nape.callbacks.ConstraintCallback) => void;
            constructor(event: nape.callbacks.CbEvent, options: any, handler: (__0: nape.callbacks.ConstraintCallback) => void, precedence?: number);
        }
        export class InteractionCallback extends nape.callbacks.Callback {
            public int1: nape.phys.Interactor;
            public int2: nape.phys.Interactor;
            public arbiters: nape.dynamics.ArbiterList;
            public toString(): String;
            constructor();
        }
        export class InteractionListener extends nape.callbacks.Listener {
            public zpp_inner_zn: zpp_nape.callbacks.ZPP_InteractionListener;
            public options1: nape.callbacks.OptionType;
            public options2: nape.callbacks.OptionType;
            public interactionType: nape.callbacks.InteractionType;
            public handler: (__0: nape.callbacks.InteractionCallback) => void;
            public allowSleepingCallbacks: boolean;
            constructor(event: nape.callbacks.CbEvent, interactionType: nape.callbacks.InteractionType, options1: any, options2: any, handler: (__0: nape.callbacks.InteractionCallback) => void, precedence?: number);
        }
        export class InteractionType {
            public static COLLISION: nape.callbacks.InteractionType;
            public static SENSOR: nape.callbacks.InteractionType;
            public static FLUID: nape.callbacks.InteractionType;
            public static ANY: nape.callbacks.InteractionType;
            public toString(): String;
            constructor();
        }
        export class ListenerIterator {
            public zpp_inner: nape.callbacks.ListenerList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.callbacks.ListenerIterator;
            public hasNext: () => boolean;
            public next: () => nape.callbacks.Listener;
            public static zpp_pool: nape.callbacks.ListenerIterator;
            public static get(list: nape.callbacks.ListenerList): nape.callbacks.ListenerIterator;
            constructor();
        }
        export class ListenerList {
            public zpp_inner: zpp_nape.util.ZPP_ListenerList;
            public length: number;
            public add: (obj: nape.callbacks.Listener) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.callbacks.ListenerIterator;
            public foreach: (lambda: (__0: nape.callbacks.Listener) => void) => nape.callbacks.ListenerList;
            public static fromArray(array: any[]): nape.callbacks.ListenerList;
            public has(obj: nape.callbacks.Listener): boolean;
            public at(index: number): nape.callbacks.Listener;
            public push(obj: nape.callbacks.Listener): boolean;
            public unshift(obj: nape.callbacks.Listener): boolean;
            public pop(): nape.callbacks.Listener;
            public shift(): nape.callbacks.Listener;
            public remove(obj: nape.callbacks.Listener): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.callbacks.ListenerList;
            public merge(xs: nape.callbacks.ListenerList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.callbacks.Listener) => boolean): nape.callbacks.ListenerList;
            constructor();
        }
        export class ListenerType {
            public static BODY: nape.callbacks.ListenerType;
            public static CONSTRAINT: nape.callbacks.ListenerType;
            public static INTERACTION: nape.callbacks.ListenerType;
            public static PRE: nape.callbacks.ListenerType;
            public toString(): String;
            constructor();
        }
        export class OptionType {
            public zpp_inner: zpp_nape.callbacks.ZPP_OptionType;
            public includes: nape.callbacks.CbTypeList;
            public excludes: nape.callbacks.CbTypeList;
            public including(includes?: any): nape.callbacks.OptionType;
            public excluding(excludes?: any): nape.callbacks.OptionType;
            public toString(): String;
            constructor(includes?: any, excludes?: any);
        }
        export class PreCallback extends nape.callbacks.Callback {
            public arbiter: nape.dynamics.Arbiter;
            public int1: nape.phys.Interactor;
            public int2: nape.phys.Interactor;
            public swapped: boolean;
            public toString(): String;
            constructor();
        }
        export class PreFlag {
            public static ACCEPT: nape.callbacks.PreFlag;
            public static IGNORE: nape.callbacks.PreFlag;
            public static ACCEPT_ONCE: nape.callbacks.PreFlag;
            public static IGNORE_ONCE: nape.callbacks.PreFlag;
            public toString(): String;
            constructor();
        }
        export class PreListener extends nape.callbacks.Listener {
            public zpp_inner_zn: zpp_nape.callbacks.ZPP_InteractionListener;
            public options1: nape.callbacks.OptionType;
            public options2: nape.callbacks.OptionType;
            public handler: (__0: nape.callbacks.PreCallback) => nape.callbacks.PreFlag;
            public pure: boolean;
            public interactionType: nape.callbacks.InteractionType;
            constructor(interactionType: nape.callbacks.InteractionType, options1: any, options2: any, handler: (__0: nape.callbacks.PreCallback) => nape.callbacks.PreFlag, precedence?: number, pure?: boolean);
        }
    }
    export module constraint {
        export class Constraint {
            public zpp_inner: zpp_nape.constraint.ZPP_Constraint;
            public userData: any;
            public debugDraw: boolean;
            public compound: nape.phys.Compound;
            public space: nape.space.Space;
            public isSleeping: boolean;
            public active: boolean;
            public ignore: boolean;
            public stiff: boolean;
            public frequency: number;
            public damping: number;
            public maxForce: number;
            public maxError: number;
            public breakUnderForce: boolean;
            public breakUnderError: boolean;
            public removeOnBreak: boolean;
            public cbTypes: nape.callbacks.CbTypeList;
            public static zpp_internalAlloc: boolean;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            public toString(): String;
            public copy(): nape.constraint.Constraint;
            constructor();
        }
        export class AngleJoint extends nape.constraint.Constraint {
            public zpp_inner_zn: zpp_nape.constraint.ZPP_AngleJoint;
            public body1: nape.phys.Body;
            public body2: nape.phys.Body;
            public jointMin: number;
            public jointMax: number;
            public ratio: number;
            public isSlack: () => boolean;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            constructor(body1: nape.phys.Body, body2: nape.phys.Body, jointMin: number, jointMax: number, ratio?: number);
        }
        export class ConstraintIterator {
            public zpp_inner: nape.constraint.ConstraintList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.constraint.ConstraintIterator;
            public hasNext: () => boolean;
            public next: () => nape.constraint.Constraint;
            public static zpp_pool: nape.constraint.ConstraintIterator;
            public static get(list: nape.constraint.ConstraintList): nape.constraint.ConstraintIterator;
            constructor();
        }
        export class ConstraintList {
            public zpp_inner: zpp_nape.util.ZPP_ConstraintList;
            public length: number;
            public add: (obj: nape.constraint.Constraint) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.constraint.ConstraintIterator;
            public foreach: (lambda: (__0: nape.constraint.Constraint) => void) => nape.constraint.ConstraintList;
            public static fromArray(array: any[]): nape.constraint.ConstraintList;
            public has(obj: nape.constraint.Constraint): boolean;
            public at(index: number): nape.constraint.Constraint;
            public push(obj: nape.constraint.Constraint): boolean;
            public unshift(obj: nape.constraint.Constraint): boolean;
            public pop(): nape.constraint.Constraint;
            public shift(): nape.constraint.Constraint;
            public remove(obj: nape.constraint.Constraint): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.constraint.ConstraintList;
            public merge(xs: nape.constraint.ConstraintList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.constraint.Constraint) => boolean): nape.constraint.ConstraintList;
            constructor();
        }
        export class DistanceJoint extends nape.constraint.Constraint {
            public zpp_inner_zn: zpp_nape.constraint.ZPP_DistanceJoint;
            public body1: nape.phys.Body;
            public body2: nape.phys.Body;
            public anchor1: nape.geom.Vec2;
            public anchor2: nape.geom.Vec2;
            public jointMin: number;
            public jointMax: number;
            public isSlack: () => boolean;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            constructor(body1: nape.phys.Body, body2: nape.phys.Body, anchor1: nape.geom.Vec2, anchor2: nape.geom.Vec2, jointMin: number, jointMax: number);
        }
        export class LineJoint extends nape.constraint.Constraint {
            public zpp_inner_zn: zpp_nape.constraint.ZPP_LineJoint;
            public body1: nape.phys.Body;
            public body2: nape.phys.Body;
            public anchor1: nape.geom.Vec2;
            public anchor2: nape.geom.Vec2;
            public direction: nape.geom.Vec2;
            public jointMin: number;
            public jointMax: number;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            constructor(body1: nape.phys.Body, body2: nape.phys.Body, anchor1: nape.geom.Vec2, anchor2: nape.geom.Vec2, direction: nape.geom.Vec2, jointMin: number, jointMax: number);
        }
        export class MotorJoint extends nape.constraint.Constraint {
            public zpp_inner_zn: zpp_nape.constraint.ZPP_MotorJoint;
            public body1: nape.phys.Body;
            public body2: nape.phys.Body;
            public ratio: number;
            public rate: number;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            constructor(body1: nape.phys.Body, body2: nape.phys.Body, rate?: number, ratio?: number);
        }
        export class PivotJoint extends nape.constraint.Constraint {
            public zpp_inner_zn: zpp_nape.constraint.ZPP_PivotJoint;
            public body1: nape.phys.Body;
            public body2: nape.phys.Body;
            public anchor1: nape.geom.Vec2;
            public anchor2: nape.geom.Vec2;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            constructor(body1: nape.phys.Body, body2: nape.phys.Body, anchor1: nape.geom.Vec2, anchor2: nape.geom.Vec2);
        }
        export class PulleyJoint extends nape.constraint.Constraint {
            public zpp_inner_zn: zpp_nape.constraint.ZPP_PulleyJoint;
            public body1: nape.phys.Body;
            public body2: nape.phys.Body;
            public body3: nape.phys.Body;
            public body4: nape.phys.Body;
            public anchor1: nape.geom.Vec2;
            public anchor2: nape.geom.Vec2;
            public anchor3: nape.geom.Vec2;
            public anchor4: nape.geom.Vec2;
            public jointMin: number;
            public jointMax: number;
            public ratio: number;
            public isSlack: () => boolean;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            constructor(body1: nape.phys.Body, body2: nape.phys.Body, body3: nape.phys.Body, body4: nape.phys.Body, anchor1: nape.geom.Vec2, anchor2: nape.geom.Vec2, anchor3: nape.geom.Vec2, anchor4: nape.geom.Vec2, jointMin: number, jointMax: number, ratio?: number);
        }
        export class UserConstraint extends nape.constraint.Constraint {
            public zpp_inner_zn: zpp_nape.constraint.ZPP_UserConstraint;
            public __bindVec2(): nape.geom.Vec2;
            public __copy(): nape.constraint.UserConstraint;
            public __broken(): void;
            public __validate(): void;
            public __draw(debug: nape.util.Debug): void;
            public __prepare(): void;
            public __position(err: number[]): void;
            public __velocity(err: number[]): void;
            public __eff_mass(eff: number[]): void;
            public __clamp(jAcc: number[]): void;
            public __impulse(imp: number[], body: nape.phys.Body, out: nape.geom.Vec3): void;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            public __invalidate(): void;
            public __registerBody(oldBody: nape.phys.Body, newBody: nape.phys.Body): nape.phys.Body;
            constructor(dimensions: number, velocityOnly?: boolean);
        }
        export class WeldJoint extends nape.constraint.Constraint {
            public zpp_inner_zn: zpp_nape.constraint.ZPP_WeldJoint;
            public body1: nape.phys.Body;
            public body2: nape.phys.Body;
            public anchor1: nape.geom.Vec2;
            public anchor2: nape.geom.Vec2;
            public phase: number;
            public impulse(): nape.geom.MatMN;
            public bodyImpulse(body: nape.phys.Body): nape.geom.Vec3;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            constructor(body1: nape.phys.Body, body2: nape.phys.Body, anchor1: nape.geom.Vec2, anchor2: nape.geom.Vec2, phase?: number);
        }
    }
    export module dynamics {
        export class Arbiter {
            public zpp_inner: zpp_nape.dynamics.ZPP_Arbiter;
            public isSleeping: boolean;
            public type: nape.dynamics.ArbiterType;
            public isCollisionArbiter: () => boolean;
            public isFluidArbiter: () => boolean;
            public isSensorArbiter: () => boolean;
            public collisionArbiter: nape.dynamics.CollisionArbiter;
            public fluidArbiter: nape.dynamics.FluidArbiter;
            public shape1: nape.shape.Shape;
            public shape2: nape.shape.Shape;
            public body1: nape.phys.Body;
            public body2: nape.phys.Body;
            public state: nape.callbacks.PreFlag;
            public totalImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            public toString(): String;
            constructor();
        }
        export class ArbiterIterator {
            public zpp_inner: nape.dynamics.ArbiterList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.dynamics.ArbiterIterator;
            public hasNext: () => boolean;
            public next: () => nape.dynamics.Arbiter;
            public static zpp_pool: nape.dynamics.ArbiterIterator;
            public static get(list: nape.dynamics.ArbiterList): nape.dynamics.ArbiterIterator;
            constructor();
        }
        export class ArbiterList {
            public zpp_inner: zpp_nape.util.ZPP_ArbiterList;
            public length: number;
            public static fromArray(array: any[]): nape.dynamics.ArbiterList;
            public zpp_gl(): number;
            public zpp_vm(): void;
            public has(obj: nape.dynamics.Arbiter): boolean;
            public at(index: number): nape.dynamics.Arbiter;
            public push(obj: nape.dynamics.Arbiter): boolean;
            public unshift(obj: nape.dynamics.Arbiter): boolean;
            public pop(): nape.dynamics.Arbiter;
            public shift(): nape.dynamics.Arbiter;
            public add(obj: nape.dynamics.Arbiter): boolean;
            public remove(obj: nape.dynamics.Arbiter): boolean;
            public clear(): void;
            public empty(): boolean;
            public iterator(): nape.dynamics.ArbiterIterator;
            public copy(deep?: boolean): nape.dynamics.ArbiterList;
            public merge(xs: nape.dynamics.ArbiterList): void;
            public toString(): String;
            public foreach(lambda: (__0: nape.dynamics.Arbiter) => void): nape.dynamics.ArbiterList;
            public filter(lambda: (__0: nape.dynamics.Arbiter) => boolean): nape.dynamics.ArbiterList;
            constructor();
        }
        export class ArbiterType {
            public static COLLISION: nape.dynamics.ArbiterType;
            public static SENSOR: nape.dynamics.ArbiterType;
            public static FLUID: nape.dynamics.ArbiterType;
            public toString(): String;
            constructor();
        }
        export class CollisionArbiter extends nape.dynamics.Arbiter {
            public contacts: nape.dynamics.ContactList;
            public normal: nape.geom.Vec2;
            public radius: number;
            public referenceEdge1: nape.shape.Edge;
            public referenceEdge2: nape.shape.Edge;
            public elasticity: number;
            public dynamicFriction: number;
            public staticFriction: number;
            public rollingFriction: number;
            public firstVertex(): boolean;
            public secondVertex(): boolean;
            public normalImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            public tangentImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            public totalImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            public rollingImpulse(body?: nape.phys.Body, freshOnly?: boolean): number;
            constructor();
        }
        export class Contact {
            public zpp_inner: zpp_nape.dynamics.ZPP_Contact;
            public arbiter: nape.dynamics.CollisionArbiter;
            public penetration: number;
            public position: nape.geom.Vec2;
            public fresh: boolean;
            public friction: number;
            public normalImpulse(body?: nape.phys.Body): nape.geom.Vec3;
            public tangentImpulse(body?: nape.phys.Body): nape.geom.Vec3;
            public rollingImpulse(body?: nape.phys.Body): number;
            public totalImpulse(body?: nape.phys.Body): nape.geom.Vec3;
            public toString(): String;
            constructor();
        }
        export class ContactIterator {
            public zpp_inner: nape.dynamics.ContactList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.dynamics.ContactIterator;
            public hasNext: () => boolean;
            public next: () => nape.dynamics.Contact;
            public static zpp_pool: nape.dynamics.ContactIterator;
            public static get(list: nape.dynamics.ContactList): nape.dynamics.ContactIterator;
            constructor();
        }
        export class ContactList {
            public zpp_inner: zpp_nape.util.ZPP_ContactList;
            public length: number;
            public add: (obj: nape.dynamics.Contact) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.dynamics.ContactIterator;
            public foreach: (lambda: (__0: nape.dynamics.Contact) => void) => nape.dynamics.ContactList;
            public static fromArray(array: any[]): nape.dynamics.ContactList;
            public has(obj: nape.dynamics.Contact): boolean;
            public at(index: number): nape.dynamics.Contact;
            public push(obj: nape.dynamics.Contact): boolean;
            public unshift(obj: nape.dynamics.Contact): boolean;
            public pop(): nape.dynamics.Contact;
            public shift(): nape.dynamics.Contact;
            public remove(obj: nape.dynamics.Contact): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.dynamics.ContactList;
            public merge(xs: nape.dynamics.ContactList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.dynamics.Contact) => boolean): nape.dynamics.ContactList;
            constructor();
        }
        export class FluidArbiter extends nape.dynamics.Arbiter {
            public position: nape.geom.Vec2;
            public overlap: number;
            public buoyancyImpulse(body?: nape.phys.Body): nape.geom.Vec3;
            public dragImpulse(body?: nape.phys.Body): nape.geom.Vec3;
            public totalImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            constructor();
        }
        export class InteractionFilter {
            public zpp_inner: zpp_nape.dynamics.ZPP_InteractionFilter;
            public userData: any;
            public shapes: nape.shape.ShapeList;
            public collisionGroup: number;
            public collisionMask: number;
            public sensorGroup: number;
            public sensorMask: number;
            public fluidGroup: number;
            public fluidMask: number;
            public shouldCollide(filter: nape.dynamics.InteractionFilter): boolean;
            public shouldSense(filter: nape.dynamics.InteractionFilter): boolean;
            public shouldFlow(filter: nape.dynamics.InteractionFilter): boolean;
            public copy(): nape.dynamics.InteractionFilter;
            public toString(): String;
            constructor(collisionGroup?: number, collisionMask?: number, sensorGroup?: number, sensorMask?: number, fluidGroup?: number, fluidMask?: number);
        }
        export class InteractionGroup {
            public zpp_inner: zpp_nape.dynamics.ZPP_InteractionGroup;
            public group: nape.dynamics.InteractionGroup;
            public ignore: boolean;
            public interactors: nape.phys.InteractorList;
            public groups: nape.dynamics.InteractionGroupList;
            public toString(): String;
            constructor(ignore?: boolean);
        }
        export class InteractionGroupIterator {
            public zpp_inner: nape.dynamics.InteractionGroupList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.dynamics.InteractionGroupIterator;
            public hasNext: () => boolean;
            public next: () => nape.dynamics.InteractionGroup;
            public static zpp_pool: nape.dynamics.InteractionGroupIterator;
            public static get(list: nape.dynamics.InteractionGroupList): nape.dynamics.InteractionGroupIterator;
            constructor();
        }
        export class InteractionGroupList {
            public zpp_inner: zpp_nape.util.ZPP_InteractionGroupList;
            public length: number;
            public add: (obj: nape.dynamics.InteractionGroup) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.dynamics.InteractionGroupIterator;
            public foreach: (lambda: (__0: nape.dynamics.InteractionGroup) => void) => nape.dynamics.InteractionGroupList;
            public static fromArray(array: any[]): nape.dynamics.InteractionGroupList;
            public has(obj: nape.dynamics.InteractionGroup): boolean;
            public at(index: number): nape.dynamics.InteractionGroup;
            public push(obj: nape.dynamics.InteractionGroup): boolean;
            public unshift(obj: nape.dynamics.InteractionGroup): boolean;
            public pop(): nape.dynamics.InteractionGroup;
            public shift(): nape.dynamics.InteractionGroup;
            public remove(obj: nape.dynamics.InteractionGroup): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.dynamics.InteractionGroupList;
            public merge(xs: nape.dynamics.InteractionGroupList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.dynamics.InteractionGroup) => boolean): nape.dynamics.InteractionGroupList;
            constructor();
        }
    }
    export module geom {
        export class AABB {
            public zpp_inner: zpp_nape.geom.ZPP_AABB;
            public min: nape.geom.Vec2;
            public max: nape.geom.Vec2;
            public x: number;
            public y: number;
            public width: number;
            public height: number;
            public copy(): nape.geom.AABB;
            public toString(): String;
            constructor(x?: number, y?: number, width?: number, height?: number);
        }
        export class ConvexResult {
            public zpp_inner: zpp_nape.geom.ZPP_ConvexRayResult;
            public normal: nape.geom.Vec2;
            public position: nape.geom.Vec2;
            public toi: number;
            public shape: nape.shape.Shape;
            public dispose: () => void;
            public toString(): String;
            constructor();
        }
        export class ConvexResultIterator {
            public zpp_inner: nape.geom.ConvexResultList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.geom.ConvexResultIterator;
            public hasNext: () => boolean;
            public next: () => nape.geom.ConvexResult;
            public static zpp_pool: nape.geom.ConvexResultIterator;
            public static get(list: nape.geom.ConvexResultList): nape.geom.ConvexResultIterator;
            constructor();
        }
        export class ConvexResultList {
            public zpp_inner: zpp_nape.util.ZPP_ConvexResultList;
            public length: number;
            public add: (obj: nape.geom.ConvexResult) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.geom.ConvexResultIterator;
            public foreach: (lambda: (__0: nape.geom.ConvexResult) => void) => nape.geom.ConvexResultList;
            public static fromArray(array: any[]): nape.geom.ConvexResultList;
            public has(obj: nape.geom.ConvexResult): boolean;
            public at(index: number): nape.geom.ConvexResult;
            public push(obj: nape.geom.ConvexResult): boolean;
            public unshift(obj: nape.geom.ConvexResult): boolean;
            public pop(): nape.geom.ConvexResult;
            public shift(): nape.geom.ConvexResult;
            public remove(obj: nape.geom.ConvexResult): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.geom.ConvexResultList;
            public merge(xs: nape.geom.ConvexResultList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.geom.ConvexResult) => boolean): nape.geom.ConvexResultList;
            constructor();
        }
        export class Geom {
            public static distanceBody(body1: nape.phys.Body, body2: nape.phys.Body, out1: nape.geom.Vec2, out2: nape.geom.Vec2): number;
            public static distance(shape1: nape.shape.Shape, shape2: nape.shape.Shape, out1: nape.geom.Vec2, out2: nape.geom.Vec2): number;
            public static intersectsBody(body1: nape.phys.Body, body2: nape.phys.Body): boolean;
            public static intersects(shape1: nape.shape.Shape, shape2: nape.shape.Shape): boolean;
            public static contains(shape1: nape.shape.Shape, shape2: nape.shape.Shape): boolean;
        }
        export class GeomPoly {
            public zpp_pool: nape.geom.GeomPoly;
            public zpp_disp: boolean;
            public zpp_inner: zpp_nape.geom.ZPP_GeomPoly;
            public empty: () => boolean;
            public iterator: () => nape.geom.GeomVertexIterator;
            public forwardIterator: () => nape.geom.GeomVertexIterator;
            public backwardsIterator: () => nape.geom.GeomVertexIterator;
            public current: () => nape.geom.Vec2;
            public skipBackwards: (times: number) => nape.geom.GeomPoly;
            public isClockwise: () => boolean;
            public isSimple: () => boolean;
            public isMonotone: () => boolean;
            public isDegenerate: () => boolean;
            public static get(vertices?: any): nape.geom.GeomPoly;
            public size(): number;
            public push(vertex: nape.geom.Vec2): nape.geom.GeomPoly;
            public pop(): nape.geom.GeomPoly;
            public unshift(vertex: nape.geom.Vec2): nape.geom.GeomPoly;
            public shift(): nape.geom.GeomPoly;
            public skipForward(times: number): nape.geom.GeomPoly;
            public erase(count: number): nape.geom.GeomPoly;
            public clear(): nape.geom.GeomPoly;
            public copy(): nape.geom.GeomPoly;
            public dispose(): void;
            public toString(): String;
            public area(): number;
            public winding(): nape.geom.Winding;
            public contains(point: nape.geom.Vec2): boolean;
            public isConvex(): boolean;
            public simplify(epsilon: number): nape.geom.GeomPoly;
            public simpleDecomposition(output?: nape.geom.GeomPolyList): nape.geom.GeomPolyList;
            public monotoneDecomposition(output?: nape.geom.GeomPolyList): nape.geom.GeomPolyList;
            public convexDecomposition(delaunay?: boolean, output?: nape.geom.GeomPolyList): nape.geom.GeomPolyList;
            public triangularDecomposition(delaunay?: boolean, output?: nape.geom.GeomPolyList): nape.geom.GeomPolyList;
            public inflate(inflation: number): nape.geom.GeomPoly;
            public cut(start: nape.geom.Vec2, end: nape.geom.Vec2, boundedStart?: boolean, boundedEnd?: boolean, output?: nape.geom.GeomPolyList): nape.geom.GeomPolyList;
            public transform(matrix: nape.geom.Mat23): nape.geom.GeomPoly;
            public bounds(): nape.geom.AABB;
            public top(): nape.geom.Vec2;
            public bottom(): nape.geom.Vec2;
            public left(): nape.geom.Vec2;
            public right(): nape.geom.Vec2;
            constructor(vertices?: any);
        }
        export class GeomPolyIterator {
            public zpp_inner: nape.geom.GeomPolyList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.geom.GeomPolyIterator;
            public hasNext: () => boolean;
            public next: () => nape.geom.GeomPoly;
            public static zpp_pool: nape.geom.GeomPolyIterator;
            public static get(list: nape.geom.GeomPolyList): nape.geom.GeomPolyIterator;
            constructor();
        }
        export class GeomPolyList {
            public zpp_inner: zpp_nape.util.ZPP_GeomPolyList;
            public length: number;
            public add: (obj: nape.geom.GeomPoly) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.geom.GeomPolyIterator;
            public foreach: (lambda: (__0: nape.geom.GeomPoly) => void) => nape.geom.GeomPolyList;
            public static fromArray(array: any[]): nape.geom.GeomPolyList;
            public has(obj: nape.geom.GeomPoly): boolean;
            public at(index: number): nape.geom.GeomPoly;
            public push(obj: nape.geom.GeomPoly): boolean;
            public unshift(obj: nape.geom.GeomPoly): boolean;
            public pop(): nape.geom.GeomPoly;
            public shift(): nape.geom.GeomPoly;
            public remove(obj: nape.geom.GeomPoly): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.geom.GeomPolyList;
            public merge(xs: nape.geom.GeomPolyList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.geom.GeomPoly) => boolean): nape.geom.GeomPolyList;
            constructor();
        }
        export class GeomVertexIterator {
            public zpp_inner: zpp_nape.geom.ZPP_GeomVertexIterator;
            public hasNext(): boolean;
            public next(): nape.geom.Vec2;
            constructor();
        }
        export type IsoFunctionDef = (__0: number, __1: number) => number;
        export class MarchingSquares {
            public static run(iso: nape.geom.IsoFunctionDef, bounds: nape.geom.AABB, cellsize: nape.geom.Vec2, quality?: number, subgrid?: nape.geom.Vec2, combine?: boolean, output?: nape.geom.GeomPolyList): nape.geom.GeomPolyList;
        }
        export class Mat23 {
            public zpp_inner: zpp_nape.geom.ZPP_Mat23;
            public a: number;
            public b: number;
            public c: number;
            public d: number;
            public tx: number;
            public ty: number;
            public reset: () => nape.geom.Mat23;
            public determinant: number;
            public static rotation(angle: number): nape.geom.Mat23;
            public static translation(tx: number, ty: number): nape.geom.Mat23;
            public static scale(sx: number, sy: number): nape.geom.Mat23;
            public copy(): nape.geom.Mat23;
            public set(matrix: nape.geom.Mat23): nape.geom.Mat23;
            public setAs(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number): nape.geom.Mat23;
            public singular(): boolean;
            public inverse(): nape.geom.Mat23;
            public transpose(): nape.geom.Mat23;
            public concat(matrix: nape.geom.Mat23): nape.geom.Mat23;
            public transform(point: nape.geom.Vec2, noTranslation?: boolean, weak?: boolean): nape.geom.Vec2;
            public inverseTransform(point: nape.geom.Vec2, noTranslation?: boolean, weak?: boolean): nape.geom.Vec2;
            public toString(): String;
            public equiorthogonal(): boolean;
            public orthogonal(): boolean;
            public equiorthogonalise(): nape.geom.Mat23;
            public orthogonalise(): nape.geom.Mat23;
            constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);
        }
        export class MatMN {
            public zpp_inner: zpp_nape.geom.ZPP_MatMN;
            public rows: number;
            public cols: number;
            public x: (row: number, col: number) => number;
            public setx: (row: number, col: number, x: number) => number;
            public toString(): String;
            public transpose(): nape.geom.MatMN;
            public mul(matrix: nape.geom.MatMN): nape.geom.MatMN;
            constructor(rows: number, cols: number);
        }
        export class Ray {
            public zpp_inner: zpp_nape.geom.ZPP_Ray;
            public userData: any;
            public origin: nape.geom.Vec2;
            public direction: nape.geom.Vec2;
            public maxDistance: number;
            public static fromSegment(start: nape.geom.Vec2, end: nape.geom.Vec2): nape.geom.Ray;
            public aabb(): nape.geom.AABB;
            public at(distance: number, weak?: boolean): nape.geom.Vec2;
            public copy(): nape.geom.Ray;
            constructor(origin: nape.geom.Vec2, direction: nape.geom.Vec2);
        }
        export class RayResult {
            public zpp_inner: zpp_nape.geom.ZPP_ConvexRayResult;
            public normal: nape.geom.Vec2;
            public distance: number;
            public inner: boolean;
            public shape: nape.shape.Shape;
            public dispose: () => void;
            public toString(): String;
            constructor();
        }
        export class RayResultIterator {
            public zpp_inner: nape.geom.RayResultList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.geom.RayResultIterator;
            public hasNext: () => boolean;
            public next: () => nape.geom.RayResult;
            public static zpp_pool: nape.geom.RayResultIterator;
            public static get(list: nape.geom.RayResultList): nape.geom.RayResultIterator;
            constructor();
        }
        export class RayResultList {
            public zpp_inner: zpp_nape.util.ZPP_RayResultList;
            public length: number;
            public add: (obj: nape.geom.RayResult) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.geom.RayResultIterator;
            public foreach: (lambda: (__0: nape.geom.RayResult) => void) => nape.geom.RayResultList;
            public static fromArray(array: any[]): nape.geom.RayResultList;
            public has(obj: nape.geom.RayResult): boolean;
            public at(index: number): nape.geom.RayResult;
            public push(obj: nape.geom.RayResult): boolean;
            public unshift(obj: nape.geom.RayResult): boolean;
            public pop(): nape.geom.RayResult;
            public shift(): nape.geom.RayResult;
            public remove(obj: nape.geom.RayResult): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.geom.RayResultList;
            public merge(xs: nape.geom.RayResultList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.geom.RayResult) => boolean): nape.geom.RayResultList;
            constructor();
        }
        export class Vec2 {
            public zpp_inner: zpp_nape.geom.ZPP_Vec2;
            public zpp_pool: nape.geom.Vec2;
            public zpp_disp: boolean;
            public dispose: () => void;
            public copy: (weak?: boolean) => nape.geom.Vec2;
            public x: number;
            public y: number;
            public length: number;
            public set: (vector: nape.geom.Vec2) => nape.geom.Vec2;
            public setxy: (x: number, y: number) => nape.geom.Vec2;
            public angle: number;
            public static weak: (x?: number, y?: number) => nape.geom.Vec2;
            public static get: (x?: number, y?: number, weak?: boolean) => nape.geom.Vec2;
            public static dsq: (a: nape.geom.Vec2, b: nape.geom.Vec2) => number;
            public static distance: (a: nape.geom.Vec2, b: nape.geom.Vec2) => number;
            public static fromPolar(length: number, angle: number, weak?: boolean): nape.geom.Vec2;
            public lsq(): number;
            public rotate(angle: number): nape.geom.Vec2;
            public reflect(vec: nape.geom.Vec2, weak?: boolean): nape.geom.Vec2;
            public normalise(): nape.geom.Vec2;
            public unit(weak?: boolean): nape.geom.Vec2;
            public add(vector: nape.geom.Vec2, weak?: boolean): nape.geom.Vec2;
            public addMul(vector: nape.geom.Vec2, scalar: number, weak?: boolean): nape.geom.Vec2;
            public sub(vector: nape.geom.Vec2, weak?: boolean): nape.geom.Vec2;
            public mul(scalar: number, weak?: boolean): nape.geom.Vec2;
            public addeq(vector: nape.geom.Vec2): nape.geom.Vec2;
            public subeq(vector: nape.geom.Vec2): nape.geom.Vec2;
            public muleq(scalar: number): nape.geom.Vec2;
            public dot(vector: nape.geom.Vec2): number;
            public cross(vector: nape.geom.Vec2): number;
            public perp(weak?: boolean): nape.geom.Vec2;
            public toString(): String;
            constructor(x?: number, y?: number);
        }
        export class Vec2Iterator {
            public zpp_inner: nape.geom.Vec2List;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.geom.Vec2Iterator;
            public hasNext: () => boolean;
            public next: () => nape.geom.Vec2;
            public static zpp_pool: nape.geom.Vec2Iterator;
            public static get(list: nape.geom.Vec2List): nape.geom.Vec2Iterator;
            constructor();
        }
        export class Vec2List {
            public zpp_inner: zpp_nape.util.ZPP_Vec2List;
            public length: number;
            public static fromArray(array: any[]): nape.geom.Vec2List;
            public zpp_gl(): number;
            public zpp_vm(): void;
            public has(obj: nape.geom.Vec2): boolean;
            public at(index: number): nape.geom.Vec2;
            public push(obj: nape.geom.Vec2): boolean;
            public unshift(obj: nape.geom.Vec2): boolean;
            public pop(): nape.geom.Vec2;
            public shift(): nape.geom.Vec2;
            public add(obj: nape.geom.Vec2): boolean;
            public remove(obj: nape.geom.Vec2): boolean;
            public clear(): void;
            public empty(): boolean;
            public iterator(): nape.geom.Vec2Iterator;
            public copy(deep?: boolean): nape.geom.Vec2List;
            public merge(xs: nape.geom.Vec2List): void;
            public toString(): String;
            public foreach(lambda: (__0: nape.geom.Vec2) => void): nape.geom.Vec2List;
            public filter(lambda: (__0: nape.geom.Vec2) => boolean): nape.geom.Vec2List;
            constructor();
        }
        export class Vec3 {
            public zpp_inner: zpp_nape.geom.ZPP_Vec3;
            public zpp_pool: nape.geom.Vec3;
            public zpp_disp: boolean;
            public x: number;
            public y: number;
            public z: number;
            public length: number;
            public static get(x?: number, y?: number, z?: number): nape.geom.Vec3;
            public dispose(): void;
            public lsq(): number;
            public set(vector: nape.geom.Vec3): nape.geom.Vec3;
            public setxyz(x: number, y: number, z: number): nape.geom.Vec3;
            public xy(weak?: boolean): nape.geom.Vec2;
            public toString(): String;
            constructor(x?: number, y?: number, z?: number);
        }
        export class Winding {
            public static UNDEFINED: nape.geom.Winding;
            public static CLOCKWISE: nape.geom.Winding;
            public static ANTICLOCKWISE: nape.geom.Winding;
            public toString(): String;
            constructor();
        }
    }
    export module phys {
        export class Interactor {
            public zpp_inner_i: zpp_nape.phys.ZPP_Interactor;
            public id: number;
            public userData: any;
            public isShape: () => boolean;
            public isBody: () => boolean;
            public isCompound: () => boolean;
            public castShape: nape.shape.Shape;
            public castBody: nape.phys.Body;
            public castCompound: nape.phys.Compound;
            public group: nape.dynamics.InteractionGroup;
            public cbTypes: nape.callbacks.CbTypeList;
            public static zpp_internalAlloc: boolean;
            public toString(): String;
            constructor();
        }
        export class Body extends nape.phys.Interactor {
            public zpp_inner: zpp_nape.phys.ZPP_Body;
            public debugDraw: boolean;
            public type: nape.phys.BodyType;
            public isBullet: boolean;
            public disableCCD: boolean;
            public isStatic: () => boolean;
            public isDynamic: () => boolean;
            public isKinematic: () => boolean;
            public shapes: nape.shape.ShapeList;
            public compound: nape.phys.Compound;
            public space: nape.space.Space;
            public arbiters: nape.dynamics.ArbiterList;
            public isSleeping: boolean;
            public constraints: nape.constraint.ConstraintList;
            public position: nape.geom.Vec2;
            public velocity: nape.geom.Vec2;
            public kinematicVel: nape.geom.Vec2;
            public surfaceVel: nape.geom.Vec2;
            public force: nape.geom.Vec2;
            public constraintVelocity: nape.geom.Vec3;
            public rotation: number;
            public angularVel: number;
            public kinAngVel: number;
            public torque: number;
            public bounds: nape.geom.AABB;
            public allowMovement: boolean;
            public allowRotation: boolean;
            public massMode: nape.phys.MassMode;
            public constraintMass: number;
            public mass: number;
            public gravMassMode: nape.phys.GravMassMode;
            public gravMass: number;
            public gravMassScale: number;
            public inertiaMode: nape.phys.InertiaMode;
            public constraintInertia: number;
            public inertia: number;
            public localCOM: nape.geom.Vec2;
            public worldCOM: nape.geom.Vec2;
            public integrate(deltaTime: number): nape.phys.Body;
            public copy(): nape.phys.Body;
            public setVelocityFromTarget(targetPosition: nape.geom.Vec2, targetRotation: number, deltaTime: number): nape.phys.Body;
            public connectedBodies(depth?: number, output?: nape.phys.BodyList): nape.phys.BodyList;
            public interactingBodies(type?: nape.callbacks.InteractionType, depth?: number, output?: nape.phys.BodyList): nape.phys.BodyList;
            public crushFactor(): number;
            public localPointToWorld(point: nape.geom.Vec2, weak?: boolean): nape.geom.Vec2;
            public worldPointToLocal(point: nape.geom.Vec2, weak?: boolean): nape.geom.Vec2;
            public localVectorToWorld(vector: nape.geom.Vec2, weak?: boolean): nape.geom.Vec2;
            public worldVectorToLocal(vector: nape.geom.Vec2, weak?: boolean): nape.geom.Vec2;
            public applyImpulse(impulse: nape.geom.Vec2, pos?: nape.geom.Vec2, sleepable?: boolean): nape.phys.Body;
            public applyAngularImpulse(impulse: number, sleepable?: boolean): nape.phys.Body;
            public translateShapes(translation: nape.geom.Vec2): nape.phys.Body;
            public rotateShapes(angle: number): nape.phys.Body;
            public scaleShapes(scaleX: number, scaleY: number): nape.phys.Body;
            public transformShapes(matrix: nape.geom.Mat23): nape.phys.Body;
            public align(): nape.phys.Body;
            public rotate(centre: nape.geom.Vec2, angle: number): nape.phys.Body;
            public setShapeMaterials(material: nape.phys.Material): nape.phys.Body;
            public setShapeFilters(filter: nape.dynamics.InteractionFilter): nape.phys.Body;
            public setShapeFluidProperties(fluidProperties: nape.phys.FluidProperties): nape.phys.Body;
            public normalImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            public tangentImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            public totalContactsImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            public rollingImpulse(body?: nape.phys.Body, freshOnly?: boolean): number;
            public buoyancyImpulse(body?: nape.phys.Body): nape.geom.Vec3;
            public dragImpulse(body?: nape.phys.Body): nape.geom.Vec3;
            public totalFluidImpulse(body?: nape.phys.Body): nape.geom.Vec3;
            public constraintsImpulse(): nape.geom.Vec3;
            public totalImpulse(body?: nape.phys.Body, freshOnly?: boolean): nape.geom.Vec3;
            public contains(point: nape.geom.Vec2): boolean;
            public toString(): String;
            constructor(type?: nape.phys.BodyType, position?: nape.geom.Vec2);
        }
        export class BodyIterator {
            public zpp_inner: nape.phys.BodyList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.phys.BodyIterator;
            public hasNext: () => boolean;
            public next: () => nape.phys.Body;
            public static zpp_pool: nape.phys.BodyIterator;
            public static get(list: nape.phys.BodyList): nape.phys.BodyIterator;
            constructor();
        }
        export class BodyList {
            public zpp_inner: zpp_nape.util.ZPP_BodyList;
            public length: number;
            public add: (obj: nape.phys.Body) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.phys.BodyIterator;
            public foreach: (lambda: (__0: nape.phys.Body) => void) => nape.phys.BodyList;
            public static fromArray(array: any[]): nape.phys.BodyList;
            public has(obj: nape.phys.Body): boolean;
            public at(index: number): nape.phys.Body;
            public push(obj: nape.phys.Body): boolean;
            public unshift(obj: nape.phys.Body): boolean;
            public pop(): nape.phys.Body;
            public shift(): nape.phys.Body;
            public remove(obj: nape.phys.Body): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.phys.BodyList;
            public merge(xs: nape.phys.BodyList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.phys.Body) => boolean): nape.phys.BodyList;
            constructor();
        }
        export class BodyType {
            public static STATIC: nape.phys.BodyType;
            public static DYNAMIC: nape.phys.BodyType;
            public static KINEMATIC: nape.phys.BodyType;
            public toString(): String;
            constructor();
        }
        export class Compound extends nape.phys.Interactor {
            public zpp_inner: zpp_nape.phys.ZPP_Compound;
            public bodies: nape.phys.BodyList;
            public constraints: nape.constraint.ConstraintList;
            public compounds: nape.phys.CompoundList;
            public compound: nape.phys.Compound;
            public space: nape.space.Space;
            public toString(): String;
            public copy(): nape.phys.Compound;
            public breakApart(): void;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            public visitConstraints(lambda: (__0: nape.constraint.Constraint) => void): void;
            public visitCompounds(lambda: (__0: nape.phys.Compound) => void): void;
            public COM(weak?: boolean): nape.geom.Vec2;
            public translate(translation: nape.geom.Vec2): nape.phys.Compound;
            public rotate(centre: nape.geom.Vec2, angle: number): nape.phys.Compound;
            constructor();
        }
        export class CompoundIterator {
            public zpp_inner: nape.phys.CompoundList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.phys.CompoundIterator;
            public hasNext: () => boolean;
            public next: () => nape.phys.Compound;
            public static zpp_pool: nape.phys.CompoundIterator;
            public static get(list: nape.phys.CompoundList): nape.phys.CompoundIterator;
            constructor();
        }
        export class CompoundList {
            public zpp_inner: zpp_nape.util.ZPP_CompoundList;
            public length: number;
            public add: (obj: nape.phys.Compound) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.phys.CompoundIterator;
            public foreach: (lambda: (__0: nape.phys.Compound) => void) => nape.phys.CompoundList;
            public static fromArray(array: any[]): nape.phys.CompoundList;
            public has(obj: nape.phys.Compound): boolean;
            public at(index: number): nape.phys.Compound;
            public push(obj: nape.phys.Compound): boolean;
            public unshift(obj: nape.phys.Compound): boolean;
            public pop(): nape.phys.Compound;
            public shift(): nape.phys.Compound;
            public remove(obj: nape.phys.Compound): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.phys.CompoundList;
            public merge(xs: nape.phys.CompoundList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.phys.Compound) => boolean): nape.phys.CompoundList;
            constructor();
        }
        export class FluidProperties {
            public zpp_inner: zpp_nape.phys.ZPP_FluidProperties;
            public userData: any;
            public shapes: nape.shape.ShapeList;
            public density: number;
            public viscosity: number;
            public gravity: nape.geom.Vec2;
            public copy(): nape.phys.FluidProperties;
            public toString(): String;
            constructor(density?: number, viscosity?: number);
        }
        export class GravMassMode {
            public static DEFAULT: nape.phys.GravMassMode;
            public static FIXED: nape.phys.GravMassMode;
            public static SCALED: nape.phys.GravMassMode;
            public toString(): String;
            constructor();
        }
        export class InertiaMode {
            public static DEFAULT: nape.phys.InertiaMode;
            public static FIXED: nape.phys.InertiaMode;
            public toString(): String;
            constructor();
        }
        export class InteractorIterator {
            public zpp_inner: nape.phys.InteractorList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.phys.InteractorIterator;
            public hasNext: () => boolean;
            public next: () => nape.phys.Interactor;
            public static zpp_pool: nape.phys.InteractorIterator;
            public static get(list: nape.phys.InteractorList): nape.phys.InteractorIterator;
            constructor();
        }
        export class InteractorList {
            public zpp_inner: zpp_nape.util.ZPP_InteractorList;
            public length: number;
            public add: (obj: nape.phys.Interactor) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.phys.InteractorIterator;
            public foreach: (lambda: (__0: nape.phys.Interactor) => void) => nape.phys.InteractorList;
            public static fromArray(array: any[]): nape.phys.InteractorList;
            public has(obj: nape.phys.Interactor): boolean;
            public at(index: number): nape.phys.Interactor;
            public push(obj: nape.phys.Interactor): boolean;
            public unshift(obj: nape.phys.Interactor): boolean;
            public pop(): nape.phys.Interactor;
            public shift(): nape.phys.Interactor;
            public remove(obj: nape.phys.Interactor): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.phys.InteractorList;
            public merge(xs: nape.phys.InteractorList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.phys.Interactor) => boolean): nape.phys.InteractorList;
            constructor();
        }
        export class MassMode {
            public static DEFAULT: nape.phys.MassMode;
            public static FIXED: nape.phys.MassMode;
            public toString(): String;
            constructor();
        }
        export class Material {
            public zpp_inner: zpp_nape.phys.ZPP_Material;
            public userData: any;
            public shapes: nape.shape.ShapeList;
            public elasticity: number;
            public dynamicFriction: number;
            public staticFriction: number;
            public density: number;
            public rollingFriction: number;
            public static wood(): nape.phys.Material;
            public static steel(): nape.phys.Material;
            public static ice(): nape.phys.Material;
            public static rubber(): nape.phys.Material;
            public static glass(): nape.phys.Material;
            public static sand(): nape.phys.Material;
            public copy(): nape.phys.Material;
            public toString(): String;
            constructor(elasticity?: number, dynamicFriction?: number, staticFriction?: number, density?: number, rollingFriction?: number);
        }
    }
    export module shape {
        export class Shape extends nape.phys.Interactor {
            public zpp_inner: zpp_nape.shape.ZPP_Shape;
            public type: nape.shape.ShapeType;
            public isCircle: () => boolean;
            public isPolygon: () => boolean;
            public body: nape.phys.Body;
            public castCircle: nape.shape.Circle;
            public castPolygon: nape.shape.Polygon;
            public worldCOM: nape.geom.Vec2;
            public localCOM: nape.geom.Vec2;
            public area: number;
            public inertia: number;
            public angDrag: number;
            public material: nape.phys.Material;
            public filter: nape.dynamics.InteractionFilter;
            public fluidProperties: nape.phys.FluidProperties;
            public fluidEnabled: boolean;
            public sensorEnabled: boolean;
            public bounds: nape.geom.AABB;
            public static zpp_internalAlloc: boolean;
            public translate(translation: nape.geom.Vec2): nape.shape.Shape;
            public scale(scalex: number, scaley: number): nape.shape.Shape;
            public rotate(angle: number): nape.shape.Shape;
            public transform(matrix: nape.geom.Mat23): nape.shape.Shape;
            public contains(point: nape.geom.Vec2): boolean;
            public copy(): nape.shape.Shape;
            public toString(): String;
        }
        export class Circle extends nape.shape.Shape {
            public zpp_inner_zn: zpp_nape.shape.ZPP_Circle;
            public radius: number;
            constructor(radius: number, localCOM?: nape.geom.Vec2, material?: nape.phys.Material, filter?: nape.dynamics.InteractionFilter);
        }
        export class Edge {
            public zpp_inner: zpp_nape.shape.ZPP_Edge;
            public polygon: nape.shape.Polygon;
            public localNormal: nape.geom.Vec2;
            public worldNormal: nape.geom.Vec2;
            public length: number;
            public localProjection: number;
            public worldProjection: number;
            public localVertex1: nape.geom.Vec2;
            public localVertex2: nape.geom.Vec2;
            public worldVertex1: nape.geom.Vec2;
            public worldVertex2: nape.geom.Vec2;
            public toString(): String;
            constructor();
        }
        export class EdgeIterator {
            public zpp_inner: nape.shape.EdgeList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.shape.EdgeIterator;
            public hasNext: () => boolean;
            public next: () => nape.shape.Edge;
            public static zpp_pool: nape.shape.EdgeIterator;
            public static get(list: nape.shape.EdgeList): nape.shape.EdgeIterator;
            constructor();
        }
        export class EdgeList {
            public zpp_inner: zpp_nape.util.ZPP_EdgeList;
            public length: number;
            public add: (obj: nape.shape.Edge) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.shape.EdgeIterator;
            public foreach: (lambda: (__0: nape.shape.Edge) => void) => nape.shape.EdgeList;
            public static fromArray(array: any[]): nape.shape.EdgeList;
            public has(obj: nape.shape.Edge): boolean;
            public at(index: number): nape.shape.Edge;
            public push(obj: nape.shape.Edge): boolean;
            public unshift(obj: nape.shape.Edge): boolean;
            public pop(): nape.shape.Edge;
            public shift(): nape.shape.Edge;
            public remove(obj: nape.shape.Edge): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.shape.EdgeList;
            public merge(xs: nape.shape.EdgeList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.shape.Edge) => boolean): nape.shape.EdgeList;
            constructor();
        }
        export class Polygon extends nape.shape.Shape {
            public zpp_inner_zn: zpp_nape.shape.ZPP_Polygon;
            public localVerts: nape.geom.Vec2List;
            public worldVerts: nape.geom.Vec2List;
            public edges: nape.shape.EdgeList;
            public static rect(x: number, y: number, width: number, height: number, weak?: boolean): any[];
            public static box(width: number, height: number, weak?: boolean): any[];
            public static regular(xRadius: number, yRadius: number, edgeCount: number, angleOffset?: number, weak?: boolean): any[];
            public validity(): nape.shape.ValidationResult;
            constructor(localVerts: any, material?: nape.phys.Material, filter?: nape.dynamics.InteractionFilter);
        }
        export class ShapeIterator {
            public zpp_inner: nape.shape.ShapeList;
            public zpp_i: number;
            public zpp_critical: boolean;
            public zpp_next: nape.shape.ShapeIterator;
            public hasNext: () => boolean;
            public next: () => nape.shape.Shape;
            public static zpp_pool: nape.shape.ShapeIterator;
            public static get(list: nape.shape.ShapeList): nape.shape.ShapeIterator;
            constructor();
        }
        export class ShapeList {
            public zpp_inner: zpp_nape.util.ZPP_ShapeList;
            public length: number;
            public add: (obj: nape.shape.Shape) => boolean;
            public empty: () => boolean;
            public iterator: () => nape.shape.ShapeIterator;
            public foreach: (lambda: (__0: nape.shape.Shape) => void) => nape.shape.ShapeList;
            public static fromArray(array: any[]): nape.shape.ShapeList;
            public has(obj: nape.shape.Shape): boolean;
            public at(index: number): nape.shape.Shape;
            public push(obj: nape.shape.Shape): boolean;
            public unshift(obj: nape.shape.Shape): boolean;
            public pop(): nape.shape.Shape;
            public shift(): nape.shape.Shape;
            public remove(obj: nape.shape.Shape): boolean;
            public clear(): void;
            public copy(deep?: boolean): nape.shape.ShapeList;
            public merge(xs: nape.shape.ShapeList): void;
            public toString(): String;
            public filter(lambda: (__0: nape.shape.Shape) => boolean): nape.shape.ShapeList;
            constructor();
        }
        export class ShapeType {
            public static CIRCLE: nape.shape.ShapeType;
            public static POLYGON: nape.shape.ShapeType;
            public toString(): String;
            constructor();
        }
        export class ValidationResult {
            public static VALID: nape.shape.ValidationResult;
            public static DEGENERATE: nape.shape.ValidationResult;
            public static CONCAVE: nape.shape.ValidationResult;
            public static SELF_INTERSECTING: nape.shape.ValidationResult;
            public toString(): String;
            constructor();
        }
    }
    export module space {
        export class Broadphase {
            public static DYNAMIC_AABB_TREE: nape.space.Broadphase;
            public static SWEEP_AND_PRUNE: nape.space.Broadphase;
            public toString(): String;
            constructor();
        }
        export class Space {
            public zpp_inner: zpp_nape.space.ZPP_Space;
            public userData: any;
            public gravity: nape.geom.Vec2;
            public broadphase: nape.space.Broadphase;
            public sortContacts: boolean;
            public worldAngularDrag: number;
            public worldLinearDrag: number;
            public compounds: nape.phys.CompoundList;
            public bodies: nape.phys.BodyList;
            public liveBodies: nape.phys.BodyList;
            public constraints: nape.constraint.ConstraintList;
            public liveConstraints: nape.constraint.ConstraintList;
            public world: nape.phys.Body;
            public arbiters: nape.dynamics.ArbiterList;
            public listeners: nape.callbacks.ListenerList;
            public timeStamp: number;
            public elapsedTime: number;
            public visitBodies(lambda: (__0: nape.phys.Body) => void): void;
            public visitConstraints(lambda: (__0: nape.constraint.Constraint) => void): void;
            public visitCompounds(lambda: (__0: nape.phys.Compound) => void): void;
            public clear(): void;
            public step(deltaTime: number, velocityIterations?: number, positionIterations?: number): void;
            public interactionType(shape1: nape.shape.Shape, shape2: nape.shape.Shape): nape.callbacks.InteractionType;
            public shapesUnderPoint(point: nape.geom.Vec2, filter?: nape.dynamics.InteractionFilter, output?: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesUnderPoint(point: nape.geom.Vec2, filter?: nape.dynamics.InteractionFilter, output?: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInAABB(aabb: nape.geom.AABB, containment?: boolean, strict?: boolean, filter?: nape.dynamics.InteractionFilter, output?: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInAABB(aabb: nape.geom.AABB, containment?: boolean, strict?: boolean, filter?: nape.dynamics.InteractionFilter, output?: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInCircle(position: nape.geom.Vec2, radius: number, containment?: boolean, filter?: nape.dynamics.InteractionFilter, output?: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInCircle(position: nape.geom.Vec2, radius: number, containment?: boolean, filter?: nape.dynamics.InteractionFilter, output?: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInShape(shape: nape.shape.Shape, containment?: boolean, filter?: nape.dynamics.InteractionFilter, output?: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInShape(shape: nape.shape.Shape, containment?: boolean, filter?: nape.dynamics.InteractionFilter, output?: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInBody(body: nape.phys.Body, filter?: nape.dynamics.InteractionFilter, output?: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInBody(body: nape.phys.Body, filter?: nape.dynamics.InteractionFilter, output?: nape.phys.BodyList): nape.phys.BodyList;
            public convexCast(shape: nape.shape.Shape, deltaTime: number, liveSweep?: boolean, filter?: nape.dynamics.InteractionFilter): nape.geom.ConvexResult;
            public convexMultiCast(shape: nape.shape.Shape, deltaTime: number, liveSweep: boolean, filter: nape.dynamics.InteractionFilter, output: nape.geom.ConvexResultList): nape.geom.ConvexResultList;
            public rayCast(ray: nape.geom.Ray, inner?: boolean, filter?: nape.dynamics.InteractionFilter): nape.geom.RayResult;
            public rayMultiCast(ray: nape.geom.Ray, inner?: boolean, filter?: nape.dynamics.InteractionFilter, output?: nape.geom.RayResultList): nape.geom.RayResultList;
            constructor(gravity?: nape.geom.Vec2, broadphase?: nape.space.Broadphase);
        }
    }
    export module util {
    }
    export class Config {
        public static epsilon: number;
        public static fluidAngularDragFriction: number;
        public static fluidAngularDrag: number;
        public static fluidVacuumDrag: number;
        public static fluidLinearDrag: number;
        public static collisionSlop: number;
        public static collisionSlopCCD: number;
        public static distanceThresholdCCD: number;
        public static staticCCDLinearThreshold: number;
        public static staticCCDAngularThreshold: number;
        public static bulletCCDLinearThreshold: number;
        public static bulletCCDAngularThreshold: number;
        public static dynamicSweepLinearThreshold: number;
        public static dynamicSweepAngularThreshold: number;
        public static angularCCDSlipScale: number;
        public static arbiterExpirationDelay: number;
        public static staticFrictionThreshold: number;
        public static elasticThreshold: number;
        public static sleepDelay: number;
        public static linearSleepThreshold: number;
        public static angularSleepThreshold: number;
        public static contactBiasCoef: number;
        public static contactStaticBiasCoef: number;
        public static contactContinuousBiasCoef: number;
        public static contactContinuousStaticBiasCoef: number;
        public static constraintLinearSlop: number;
        public static constraintAngularSlop: number;
        public static illConditionedThreshold: number;
    }
    export type TArray = any[];
}
declare module zpp_nape {
    export module callbacks {
        export class ZPP_Callback {
            public outer_body: nape.callbacks.BodyCallback;
            public outer_con: nape.callbacks.ConstraintCallback;
            public outer_int: nape.callbacks.InteractionCallback;
            public event: number;
            public listener: zpp_nape.callbacks.ZPP_Listener;
            public space: zpp_nape.space.ZPP_Space;
            public index: number;
            public next: zpp_nape.callbacks.ZPP_Callback;
            public prev: zpp_nape.callbacks.ZPP_Callback;
            public length: number;
            public free: () => void;
            public alloc: () => void;
            public int1: zpp_nape.phys.ZPP_Interactor;
            public int2: zpp_nape.phys.ZPP_Interactor;
            public set: zpp_nape.space.ZPP_CallbackSet;
            public wrap_arbiters: nape.dynamics.ArbiterList;
            public pre_arbiter: zpp_nape.dynamics.ZPP_Arbiter;
            public pre_swapped: boolean;
            public genarbs: () => void;
            public body: zpp_nape.phys.ZPP_Body;
            public constraint: zpp_nape.constraint.ZPP_Constraint;
            public static internal: boolean;
            public static zpp_pool: zpp_nape.callbacks.ZPP_Callback;
            public wrapper_body(): nape.callbacks.BodyCallback;
            public wrapper_con(): nape.callbacks.ConstraintCallback;
            public wrapper_int(): nape.callbacks.InteractionCallback;
            public push(obj: zpp_nape.callbacks.ZPP_Callback): void;
            public push_rev(obj: zpp_nape.callbacks.ZPP_Callback): void;
            public pop(): zpp_nape.callbacks.ZPP_Callback;
            public pop_rev(): zpp_nape.callbacks.ZPP_Callback;
            public empty(): boolean;
            public clear(): void;
            public splice(o: zpp_nape.callbacks.ZPP_Callback): zpp_nape.callbacks.ZPP_Callback;
            public rotateL(): void;
            public rotateR(): void;
            public cycleNext(o: zpp_nape.callbacks.ZPP_Callback): zpp_nape.callbacks.ZPP_Callback;
            public cyclePrev(o: zpp_nape.callbacks.ZPP_Callback): zpp_nape.callbacks.ZPP_Callback;
            public at(i: number): zpp_nape.callbacks.ZPP_Callback;
            public rev_at(i: number): zpp_nape.callbacks.ZPP_Callback;
            constructor();
        }
        export class ZPP_CbSet {
            public cbTypes: zpp_nape.util.ZNPList_ZPP_CbType;
            public count: number;
            public next: zpp_nape.callbacks.ZPP_CbSet;
            public id: number;
            public manager: zpp_nape.space.ZPP_CbSetManager;
            public cbpairs: zpp_nape.util.ZNPList_ZPP_CbSetPair;
            public increment: () => void;
            public decrement: () => boolean;
            public listeners: zpp_nape.util.ZNPList_ZPP_InteractionListener;
            public zip_listeners: boolean;
            public invalidate_listeners: () => void;
            public validate_listeners: () => void;
            public bodylisteners: zpp_nape.util.ZNPList_ZPP_BodyListener;
            public zip_bodylisteners: boolean;
            public invalidate_bodylisteners: () => void;
            public validate_bodylisteners: () => void;
            public conlisteners: zpp_nape.util.ZNPList_ZPP_ConstraintListener;
            public zip_conlisteners: boolean;
            public invalidate_conlisteners: () => void;
            public validate_conlisteners: () => void;
            public interactors: zpp_nape.util.ZNPList_ZPP_Interactor;
            public wrap_interactors: nape.phys.InteractorList;
            public constraints: zpp_nape.util.ZNPList_ZPP_Constraint;
            public wrap_constraints: nape.constraint.ConstraintList;
            public addConstraint: (con: zpp_nape.constraint.ZPP_Constraint) => void;
            public addInteractor: (intx: zpp_nape.phys.ZPP_Interactor) => void;
            public remConstraint: (con: zpp_nape.constraint.ZPP_Constraint) => void;
            public remInteractor: (intx: zpp_nape.phys.ZPP_Interactor) => void;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.callbacks.ZPP_CbSet;
            public static empty_intersection: (a: zpp_nape.callbacks.ZPP_CbSet, b: zpp_nape.callbacks.ZPP_CbSet) => boolean;
            public static find_all: (a: zpp_nape.callbacks.ZPP_CbSet, b: zpp_nape.callbacks.ZPP_CbSet, event: number, cb: (__0: zpp_nape.callbacks.ZPP_InteractionListener) => void) => void;
            public static setlt(a: zpp_nape.callbacks.ZPP_CbSet, b: zpp_nape.callbacks.ZPP_CbSet): boolean;
            public static get(cbTypes: zpp_nape.util.ZNPList_ZPP_CbType): zpp_nape.callbacks.ZPP_CbSet;
            public static single_intersection(a: zpp_nape.callbacks.ZPP_CbSet, b: zpp_nape.callbacks.ZPP_CbSet, i: zpp_nape.callbacks.ZPP_InteractionListener): boolean;
            public invalidate_pairs(): void;
            public realvalidate_listeners(): void;
            public realvalidate_bodylisteners(): void;
            public realvalidate_conlisteners(): void;
            public validate(): void;
            constructor();
        }
        export class ZPP_CbSetPair {
            public a: zpp_nape.callbacks.ZPP_CbSet;
            public b: zpp_nape.callbacks.ZPP_CbSet;
            public next: zpp_nape.callbacks.ZPP_CbSetPair;
            public free: () => void;
            public alloc: () => void;
            public zip_listeners: boolean;
            public listeners: zpp_nape.util.ZNPList_ZPP_InteractionListener;
            public invalidate: () => void;
            public validate: () => void;
            public empty_intersection: () => boolean;
            public single_intersection: (i: zpp_nape.callbacks.ZPP_InteractionListener) => boolean;
            public forall: (event: number, cb: (__0: zpp_nape.callbacks.ZPP_InteractionListener) => void) => void;
            public static zpp_pool: zpp_nape.callbacks.ZPP_CbSetPair;
            public static get: (a: zpp_nape.callbacks.ZPP_CbSet, b: zpp_nape.callbacks.ZPP_CbSet) => zpp_nape.callbacks.ZPP_CbSetPair;
            public static setlt: (x: zpp_nape.callbacks.ZPP_CbSetPair, y: zpp_nape.callbacks.ZPP_CbSetPair) => boolean;
            public __validate(): void;
            constructor();
        }
        export class ZPP_CbType {
            public outer: nape.callbacks.CbType;
            public userData: any;
            public id: number;
            public cbsets: zpp_nape.util.ZNPList_ZPP_CbSet;
            public interactors: zpp_nape.util.ZNPList_ZPP_Interactor;
            public wrap_interactors: nape.phys.InteractorList;
            public constraints: zpp_nape.util.ZNPList_ZPP_Constraint;
            public wrap_constraints: nape.constraint.ConstraintList;
            public addConstraint: (con: zpp_nape.constraint.ZPP_Constraint) => void;
            public addInteractor: (intx: zpp_nape.phys.ZPP_Interactor) => void;
            public remConstraint: (con: zpp_nape.constraint.ZPP_Constraint) => void;
            public remInteractor: (intx: zpp_nape.phys.ZPP_Interactor) => void;
            public listeners: zpp_nape.util.ZNPList_ZPP_InteractionListener;
            public addint: (x: zpp_nape.callbacks.ZPP_InteractionListener) => void;
            public removeint: (x: zpp_nape.callbacks.ZPP_InteractionListener) => void;
            public invalidateint: () => void;
            public bodylisteners: zpp_nape.util.ZNPList_ZPP_BodyListener;
            public addbody: (x: zpp_nape.callbacks.ZPP_BodyListener) => void;
            public removebody: (x: zpp_nape.callbacks.ZPP_BodyListener) => void;
            public invalidatebody: () => void;
            public conlisteners: zpp_nape.util.ZNPList_ZPP_ConstraintListener;
            public addconstraint: (x: zpp_nape.callbacks.ZPP_ConstraintListener) => void;
            public removeconstraint: (x: zpp_nape.callbacks.ZPP_ConstraintListener) => void;
            public invalidateconstraint: () => void;
            public static setlt: (a: zpp_nape.callbacks.ZPP_CbType, b: zpp_nape.callbacks.ZPP_CbType) => boolean;
            public static ANY_SHAPE: nape.callbacks.CbType;
            public static ANY_BODY: nape.callbacks.CbType;
            public static ANY_COMPOUND: nape.callbacks.CbType;
            public static ANY_CONSTRAINT: nape.callbacks.CbType;
            constructor();
        }
        export class ZPP_Listener {
            public outer: nape.callbacks.Listener;
            public id: number;
            public type: number;
            public event: number;
            public precedence: number;
            public body: zpp_nape.callbacks.ZPP_BodyListener;
            public constraint: zpp_nape.callbacks.ZPP_ConstraintListener;
            public interaction: zpp_nape.callbacks.ZPP_InteractionListener;
            public space: zpp_nape.space.ZPP_Space;
            public static internal: boolean;
            public static types: any[];
            public static events: any[];
            public static setlt: (a: zpp_nape.callbacks.ZPP_Listener, b: zpp_nape.callbacks.ZPP_Listener) => boolean;
            public swapEvent(event: number): void;
            public invalidate_precedence(): void;
            public addedToSpace(): void;
            public removedFromSpace(): void;
        }
        export class ZPP_BodyListener extends zpp_nape.callbacks.ZPP_Listener {
            public outer_zn: nape.callbacks.BodyListener;
            public options: zpp_nape.callbacks.ZPP_OptionType;
            public handler: (__0: nape.callbacks.BodyCallback) => void;
            public addedToSpace(): void;
            public removedFromSpace(): void;
            public invalidate_precedence(): void;
            public swapEvent(newev: number): void;
            constructor(options: nape.callbacks.OptionType, event: number, handler: (__0: nape.callbacks.BodyCallback) => void);
        }
        export class ZPP_ConstraintListener extends zpp_nape.callbacks.ZPP_Listener {
            public outer_zn: nape.callbacks.ConstraintListener;
            public options: zpp_nape.callbacks.ZPP_OptionType;
            public handler: (__0: nape.callbacks.ConstraintCallback) => void;
            public addedToSpace(): void;
            public removedFromSpace(): void;
            public invalidate_precedence(): void;
            public swapEvent(newev: number): void;
            constructor(options: nape.callbacks.OptionType, event: number, handler: (__0: nape.callbacks.ConstraintCallback) => void);
        }
        export class ZPP_InteractionListener extends zpp_nape.callbacks.ZPP_Listener {
            public outer_zni: nape.callbacks.InteractionListener;
            public outer_znp: nape.callbacks.PreListener;
            public itype: number;
            public options1: zpp_nape.callbacks.ZPP_OptionType;
            public options2: zpp_nape.callbacks.ZPP_OptionType;
            public handleri: (__0: nape.callbacks.InteractionCallback) => void;
            public allowSleepingCallbacks: boolean;
            public pure: boolean;
            public handlerp: (__0: nape.callbacks.PreCallback) => nape.callbacks.PreFlag;
            public setInteractionType: (itype: number) => void;
            public wake(): void;
            public addedToSpace(): void;
            public removedFromSpace(): void;
            public invalidate_precedence(): void;
            public swapEvent(newev: number): void;
            constructor(options1: nape.callbacks.OptionType, options2: nape.callbacks.OptionType, event: number, type: number);
        }
        export class ZPP_OptionType {
            public outer: nape.callbacks.OptionType;
            public handler: (__0: zpp_nape.callbacks.ZPP_CbType, __1: boolean, __2: boolean) => void;
            public includes: zpp_nape.util.ZNPList_ZPP_CbType;
            public excludes: zpp_nape.util.ZNPList_ZPP_CbType;
            public wrap_includes: nape.callbacks.CbTypeList;
            public wrap_excludes: nape.callbacks.CbTypeList;
            public excluded: (xs: zpp_nape.util.ZNPList_ZPP_CbType) => boolean;
            public included: (xs: zpp_nape.util.ZNPList_ZPP_CbType) => boolean;
            public compatible: (xs: zpp_nape.util.ZNPList_ZPP_CbType) => boolean;
            public effect_change: (val: zpp_nape.callbacks.ZPP_CbType, included: boolean, added: boolean) => void;
            public static argument(val: any): nape.callbacks.OptionType;
            public setup_includes(): void;
            public setup_excludes(): void;
            public nonemptyintersection(xs: zpp_nape.util.ZNPList_ZPP_CbType, ys: zpp_nape.util.ZNPList_ZPP_CbType): boolean;
            public set(options: zpp_nape.callbacks.ZPP_OptionType): zpp_nape.callbacks.ZPP_OptionType;
            public append(list: zpp_nape.util.ZNPList_ZPP_CbType, val: any): void;
            constructor();
        }
    }
    export module util {
        export class ZNPList_ZPP_InteractionListener {
            public head: zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_InteractionListener) => void;
            public inlined_add: (o: zpp_nape.callbacks.ZPP_InteractionListener) => zpp_nape.callbacks.ZPP_InteractionListener;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_InteractionListener, o: zpp_nape.callbacks.ZPP_InteractionListener) => zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.callbacks.ZPP_InteractionListener;
            public inlined_remove: (obj: zpp_nape.callbacks.ZPP_InteractionListener) => void;
            public inlined_try_remove: (obj: zpp_nape.callbacks.ZPP_InteractionListener) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_InteractionListener) => zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.callbacks.ZPP_InteractionListener) => boolean;
            public front: () => zpp_nape.callbacks.ZPP_InteractionListener;
            public add(o: zpp_nape.callbacks.ZPP_InteractionListener): zpp_nape.callbacks.ZPP_InteractionListener;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_InteractionListener): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_InteractionListener, o: zpp_nape.callbacks.ZPP_InteractionListener): zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public pop(): void;
            public pop_unsafe(): zpp_nape.callbacks.ZPP_InteractionListener;
            public remove(obj: zpp_nape.callbacks.ZPP_InteractionListener): void;
            public try_remove(obj: zpp_nape.callbacks.ZPP_InteractionListener): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_InteractionListener): zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_InteractionListener, n: number): zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.callbacks.ZPP_InteractionListener): boolean;
            public back(): zpp_nape.callbacks.ZPP_InteractionListener;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public at(ind: number): zpp_nape.callbacks.ZPP_InteractionListener;
            constructor();
        }
        export class ZNPList_ZPP_BodyListener {
            public head: zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_BodyListener) => void;
            public inlined_add: (o: zpp_nape.callbacks.ZPP_BodyListener) => zpp_nape.callbacks.ZPP_BodyListener;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_BodyListener, o: zpp_nape.callbacks.ZPP_BodyListener) => zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.callbacks.ZPP_BodyListener;
            public inlined_remove: (obj: zpp_nape.callbacks.ZPP_BodyListener) => void;
            public inlined_try_remove: (obj: zpp_nape.callbacks.ZPP_BodyListener) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_BodyListener) => zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.callbacks.ZPP_BodyListener) => boolean;
            public front: () => zpp_nape.callbacks.ZPP_BodyListener;
            public add(o: zpp_nape.callbacks.ZPP_BodyListener): zpp_nape.callbacks.ZPP_BodyListener;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_BodyListener): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_BodyListener, o: zpp_nape.callbacks.ZPP_BodyListener): zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public pop(): void;
            public pop_unsafe(): zpp_nape.callbacks.ZPP_BodyListener;
            public remove(obj: zpp_nape.callbacks.ZPP_BodyListener): void;
            public try_remove(obj: zpp_nape.callbacks.ZPP_BodyListener): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_BodyListener): zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_BodyListener, n: number): zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.callbacks.ZPP_BodyListener): boolean;
            public back(): zpp_nape.callbacks.ZPP_BodyListener;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public at(ind: number): zpp_nape.callbacks.ZPP_BodyListener;
            constructor();
        }
        export class ZNPList_ZPP_ConstraintListener {
            public head: zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_ConstraintListener) => void;
            public inlined_add: (o: zpp_nape.callbacks.ZPP_ConstraintListener) => zpp_nape.callbacks.ZPP_ConstraintListener;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_ConstraintListener, o: zpp_nape.callbacks.ZPP_ConstraintListener) => zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.callbacks.ZPP_ConstraintListener;
            public inlined_remove: (obj: zpp_nape.callbacks.ZPP_ConstraintListener) => void;
            public inlined_try_remove: (obj: zpp_nape.callbacks.ZPP_ConstraintListener) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_ConstraintListener) => zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.callbacks.ZPP_ConstraintListener) => boolean;
            public front: () => zpp_nape.callbacks.ZPP_ConstraintListener;
            public add(o: zpp_nape.callbacks.ZPP_ConstraintListener): zpp_nape.callbacks.ZPP_ConstraintListener;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_ConstraintListener): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_ConstraintListener, o: zpp_nape.callbacks.ZPP_ConstraintListener): zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public pop(): void;
            public pop_unsafe(): zpp_nape.callbacks.ZPP_ConstraintListener;
            public remove(obj: zpp_nape.callbacks.ZPP_ConstraintListener): void;
            public try_remove(obj: zpp_nape.callbacks.ZPP_ConstraintListener): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_ConstraintListener): zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_ConstraintListener, n: number): zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.callbacks.ZPP_ConstraintListener): boolean;
            public back(): zpp_nape.callbacks.ZPP_ConstraintListener;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public at(ind: number): zpp_nape.callbacks.ZPP_ConstraintListener;
            constructor();
        }
        export class ZNPList_ZPP_Constraint {
            public head: zpp_nape.util.ZNPNode_ZPP_Constraint;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Constraint;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Constraint) => void;
            public inlined_add: (o: zpp_nape.constraint.ZPP_Constraint) => zpp_nape.constraint.ZPP_Constraint;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Constraint, o: zpp_nape.constraint.ZPP_Constraint) => zpp_nape.util.ZNPNode_ZPP_Constraint;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.constraint.ZPP_Constraint;
            public inlined_remove: (obj: zpp_nape.constraint.ZPP_Constraint) => void;
            public inlined_try_remove: (obj: zpp_nape.constraint.ZPP_Constraint) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Constraint) => zpp_nape.util.ZNPNode_ZPP_Constraint;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.constraint.ZPP_Constraint) => boolean;
            public front: () => zpp_nape.constraint.ZPP_Constraint;
            public add(o: zpp_nape.constraint.ZPP_Constraint): zpp_nape.constraint.ZPP_Constraint;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Constraint): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Constraint, o: zpp_nape.constraint.ZPP_Constraint): zpp_nape.util.ZNPNode_ZPP_Constraint;
            public pop(): void;
            public pop_unsafe(): zpp_nape.constraint.ZPP_Constraint;
            public remove(obj: zpp_nape.constraint.ZPP_Constraint): void;
            public try_remove(obj: zpp_nape.constraint.ZPP_Constraint): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Constraint): zpp_nape.util.ZNPNode_ZPP_Constraint;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Constraint, n: number): zpp_nape.util.ZNPNode_ZPP_Constraint;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.constraint.ZPP_Constraint): boolean;
            public back(): zpp_nape.constraint.ZPP_Constraint;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Constraint;
            public at(ind: number): zpp_nape.constraint.ZPP_Constraint;
            constructor();
        }
        export class ZNPList_ZPP_Interactor {
            public head: zpp_nape.util.ZNPNode_ZPP_Interactor;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Interactor;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Interactor) => void;
            public inlined_add: (o: zpp_nape.phys.ZPP_Interactor) => zpp_nape.phys.ZPP_Interactor;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Interactor, o: zpp_nape.phys.ZPP_Interactor) => zpp_nape.util.ZNPNode_ZPP_Interactor;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.phys.ZPP_Interactor;
            public inlined_remove: (obj: zpp_nape.phys.ZPP_Interactor) => void;
            public inlined_try_remove: (obj: zpp_nape.phys.ZPP_Interactor) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Interactor) => zpp_nape.util.ZNPNode_ZPP_Interactor;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.phys.ZPP_Interactor) => boolean;
            public front: () => zpp_nape.phys.ZPP_Interactor;
            public add(o: zpp_nape.phys.ZPP_Interactor): zpp_nape.phys.ZPP_Interactor;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Interactor): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Interactor, o: zpp_nape.phys.ZPP_Interactor): zpp_nape.util.ZNPNode_ZPP_Interactor;
            public pop(): void;
            public pop_unsafe(): zpp_nape.phys.ZPP_Interactor;
            public remove(obj: zpp_nape.phys.ZPP_Interactor): void;
            public try_remove(obj: zpp_nape.phys.ZPP_Interactor): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Interactor): zpp_nape.util.ZNPNode_ZPP_Interactor;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Interactor, n: number): zpp_nape.util.ZNPNode_ZPP_Interactor;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.phys.ZPP_Interactor): boolean;
            public back(): zpp_nape.phys.ZPP_Interactor;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Interactor;
            public at(ind: number): zpp_nape.phys.ZPP_Interactor;
            constructor();
        }
        export class ZNPList_ZPP_CbSet {
            public head: zpp_nape.util.ZNPNode_ZPP_CbSet;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_CbSet;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_CbSet) => void;
            public inlined_add: (o: zpp_nape.callbacks.ZPP_CbSet) => zpp_nape.callbacks.ZPP_CbSet;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_CbSet, o: zpp_nape.callbacks.ZPP_CbSet) => zpp_nape.util.ZNPNode_ZPP_CbSet;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.callbacks.ZPP_CbSet;
            public inlined_remove: (obj: zpp_nape.callbacks.ZPP_CbSet) => void;
            public inlined_try_remove: (obj: zpp_nape.callbacks.ZPP_CbSet) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_CbSet) => zpp_nape.util.ZNPNode_ZPP_CbSet;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.callbacks.ZPP_CbSet) => boolean;
            public front: () => zpp_nape.callbacks.ZPP_CbSet;
            public add(o: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.callbacks.ZPP_CbSet;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_CbSet): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_CbSet, o: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.util.ZNPNode_ZPP_CbSet;
            public pop(): void;
            public pop_unsafe(): zpp_nape.callbacks.ZPP_CbSet;
            public remove(obj: zpp_nape.callbacks.ZPP_CbSet): void;
            public try_remove(obj: zpp_nape.callbacks.ZPP_CbSet): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_CbSet): zpp_nape.util.ZNPNode_ZPP_CbSet;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_CbSet, n: number): zpp_nape.util.ZNPNode_ZPP_CbSet;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.callbacks.ZPP_CbSet): boolean;
            public back(): zpp_nape.callbacks.ZPP_CbSet;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_CbSet;
            public at(ind: number): zpp_nape.callbacks.ZPP_CbSet;
            constructor();
        }
        export class ZPP_Flags {
            public static internal: boolean;
            public static id_ImmState_ACCEPT: number;
            public static id_ImmState_IGNORE: number;
            public static id_ImmState_ALWAYS: number;
            public static id_GravMassMode_DEFAULT: number;
            public static id_GravMassMode_FIXED: number;
            public static id_GravMassMode_SCALED: number;
            public static id_InertiaMode_DEFAULT: number;
            public static id_InertiaMode_FIXED: number;
            public static id_MassMode_DEFAULT: number;
            public static id_MassMode_FIXED: number;
            public static id_BodyType_STATIC: number;
            public static id_BodyType_DYNAMIC: number;
            public static id_BodyType_KINEMATIC: number;
            public static id_ListenerType_BODY: number;
            public static id_PreFlag_ACCEPT: number;
            public static id_ListenerType_CONSTRAINT: number;
            public static id_PreFlag_IGNORE: number;
            public static id_ListenerType_INTERACTION: number;
            public static id_PreFlag_ACCEPT_ONCE: number;
            public static id_ListenerType_PRE: number;
            public static id_PreFlag_IGNORE_ONCE: number;
            public static id_CbEvent_BEGIN: number;
            public static id_InteractionType_COLLISION: number;
            public static id_CbEvent_ONGOING: number;
            public static id_InteractionType_SENSOR: number;
            public static id_CbEvent_END: number;
            public static id_InteractionType_FLUID: number;
            public static id_CbEvent_WAKE: number;
            public static id_InteractionType_ANY: number;
            public static id_CbEvent_SLEEP: number;
            public static id_CbEvent_BREAK: number;
            public static id_CbEvent_PRE: number;
            public static id_Winding_UNDEFINED: number;
            public static id_Winding_CLOCKWISE: number;
            public static id_Winding_ANTICLOCKWISE: number;
            public static id_ValidationResult_VALID: number;
            public static id_ValidationResult_DEGENERATE: number;
            public static id_ValidationResult_CONCAVE: number;
            public static id_ValidationResult_SELF_INTERSECTING: number;
            public static id_ShapeType_CIRCLE: number;
            public static id_ShapeType_POLYGON: number;
            public static id_Broadphase_DYNAMIC_AABB_TREE: number;
            public static id_Broadphase_SWEEP_AND_PRUNE: number;
            public static id_ArbiterType_COLLISION: number;
            public static id_ArbiterType_SENSOR: number;
            public static id_ArbiterType_FLUID: number;
            public static GravMassMode_DEFAULT: nape.phys.GravMassMode;
            public static GravMassMode_FIXED: nape.phys.GravMassMode;
            public static GravMassMode_SCALED: nape.phys.GravMassMode;
            public static InertiaMode_DEFAULT: nape.phys.InertiaMode;
            public static InertiaMode_FIXED: nape.phys.InertiaMode;
            public static MassMode_DEFAULT: nape.phys.MassMode;
            public static MassMode_FIXED: nape.phys.MassMode;
            public static BodyType_STATIC: nape.phys.BodyType;
            public static BodyType_DYNAMIC: nape.phys.BodyType;
            public static BodyType_KINEMATIC: nape.phys.BodyType;
            public static ListenerType_BODY: nape.callbacks.ListenerType;
            public static PreFlag_ACCEPT: nape.callbacks.PreFlag;
            public static ListenerType_CONSTRAINT: nape.callbacks.ListenerType;
            public static PreFlag_IGNORE: nape.callbacks.PreFlag;
            public static ListenerType_INTERACTION: nape.callbacks.ListenerType;
            public static PreFlag_ACCEPT_ONCE: nape.callbacks.PreFlag;
            public static ListenerType_PRE: nape.callbacks.ListenerType;
            public static PreFlag_IGNORE_ONCE: nape.callbacks.PreFlag;
            public static CbEvent_BEGIN: nape.callbacks.CbEvent;
            public static InteractionType_COLLISION: nape.callbacks.InteractionType;
            public static CbEvent_ONGOING: nape.callbacks.CbEvent;
            public static InteractionType_SENSOR: nape.callbacks.InteractionType;
            public static CbEvent_END: nape.callbacks.CbEvent;
            public static InteractionType_FLUID: nape.callbacks.InteractionType;
            public static CbEvent_WAKE: nape.callbacks.CbEvent;
            public static InteractionType_ANY: nape.callbacks.InteractionType;
            public static CbEvent_SLEEP: nape.callbacks.CbEvent;
            public static CbEvent_BREAK: nape.callbacks.CbEvent;
            public static CbEvent_PRE: nape.callbacks.CbEvent;
            public static Winding_UNDEFINED: nape.geom.Winding;
            public static Winding_CLOCKWISE: nape.geom.Winding;
            public static Winding_ANTICLOCKWISE: nape.geom.Winding;
            public static ValidationResult_VALID: nape.shape.ValidationResult;
            public static ValidationResult_DEGENERATE: nape.shape.ValidationResult;
            public static ValidationResult_CONCAVE: nape.shape.ValidationResult;
            public static ValidationResult_SELF_INTERSECTING: nape.shape.ValidationResult;
            public static ShapeType_CIRCLE: nape.shape.ShapeType;
            public static ShapeType_POLYGON: nape.shape.ShapeType;
            public static Broadphase_DYNAMIC_AABB_TREE: nape.space.Broadphase;
            public static Broadphase_SWEEP_AND_PRUNE: nape.space.Broadphase;
            public static ArbiterType_COLLISION: nape.dynamics.ArbiterType;
            public static ArbiterType_SENSOR: nape.dynamics.ArbiterType;
            public static ArbiterType_FLUID: nape.dynamics.ArbiterType;
        }
        export class ZNPList_ZPP_CbType {
            public head: zpp_nape.util.ZNPNode_ZPP_CbType;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_CbType;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_CbType) => void;
            public inlined_add: (o: zpp_nape.callbacks.ZPP_CbType) => zpp_nape.callbacks.ZPP_CbType;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_CbType, o: zpp_nape.callbacks.ZPP_CbType) => zpp_nape.util.ZNPNode_ZPP_CbType;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.callbacks.ZPP_CbType;
            public inlined_remove: (obj: zpp_nape.callbacks.ZPP_CbType) => void;
            public inlined_try_remove: (obj: zpp_nape.callbacks.ZPP_CbType) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_CbType) => zpp_nape.util.ZNPNode_ZPP_CbType;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.callbacks.ZPP_CbType) => boolean;
            public front: () => zpp_nape.callbacks.ZPP_CbType;
            public add(o: zpp_nape.callbacks.ZPP_CbType): zpp_nape.callbacks.ZPP_CbType;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_CbType): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_CbType, o: zpp_nape.callbacks.ZPP_CbType): zpp_nape.util.ZNPNode_ZPP_CbType;
            public pop(): void;
            public pop_unsafe(): zpp_nape.callbacks.ZPP_CbType;
            public remove(obj: zpp_nape.callbacks.ZPP_CbType): void;
            public try_remove(obj: zpp_nape.callbacks.ZPP_CbType): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_CbType): zpp_nape.util.ZNPNode_ZPP_CbType;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_CbType, n: number): zpp_nape.util.ZNPNode_ZPP_CbType;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.callbacks.ZPP_CbType): boolean;
            public back(): zpp_nape.callbacks.ZPP_CbType;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_CbType;
            public at(ind: number): zpp_nape.callbacks.ZPP_CbType;
            constructor();
        }
        export class ZNPList_ZPP_Vec2 {
            public head: zpp_nape.util.ZNPNode_ZPP_Vec2;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Vec2;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Vec2) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_Vec2) => zpp_nape.geom.ZPP_Vec2;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Vec2, o: zpp_nape.geom.ZPP_Vec2) => zpp_nape.util.ZNPNode_ZPP_Vec2;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_Vec2;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_Vec2) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_Vec2) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Vec2) => zpp_nape.util.ZNPNode_ZPP_Vec2;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_Vec2) => boolean;
            public front: () => zpp_nape.geom.ZPP_Vec2;
            public add(o: zpp_nape.geom.ZPP_Vec2): zpp_nape.geom.ZPP_Vec2;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Vec2): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Vec2, o: zpp_nape.geom.ZPP_Vec2): zpp_nape.util.ZNPNode_ZPP_Vec2;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_Vec2;
            public remove(obj: zpp_nape.geom.ZPP_Vec2): void;
            public try_remove(obj: zpp_nape.geom.ZPP_Vec2): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Vec2): zpp_nape.util.ZNPNode_ZPP_Vec2;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Vec2, n: number): zpp_nape.util.ZNPNode_ZPP_Vec2;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_Vec2): boolean;
            public back(): zpp_nape.geom.ZPP_Vec2;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Vec2;
            public at(ind: number): zpp_nape.geom.ZPP_Vec2;
            constructor();
        }
        export class ZNPArray2_Float {
            public list: number[];
            public width: number;
            public get: (x: number, y: number) => number;
            public set: (x: number, y: number, obj: number) => number;
            public resize(width: number, height: number, def: number): void;
            constructor(width: number, height: number);
        }
        export class ZNPArray2_ZPP_GeomVert {
            public list: zpp_nape.geom.ZPP_GeomVert[];
            public width: number;
            public get: (x: number, y: number) => zpp_nape.geom.ZPP_GeomVert;
            public set: (x: number, y: number, obj: zpp_nape.geom.ZPP_GeomVert) => zpp_nape.geom.ZPP_GeomVert;
            public resize(width: number, height: number, def: zpp_nape.geom.ZPP_GeomVert): void;
            constructor(width: number, height: number);
        }
        export class ZNPArray2_ZPP_MarchPair {
            public list: zpp_nape.geom.ZPP_MarchPair[];
            public width: number;
            public get: (x: number, y: number) => zpp_nape.geom.ZPP_MarchPair;
            public set: (x: number, y: number, obj: zpp_nape.geom.ZPP_MarchPair) => zpp_nape.geom.ZPP_MarchPair;
            public resize(width: number, height: number, def: zpp_nape.geom.ZPP_MarchPair): void;
            constructor(width: number, height: number);
        }
        export class Hashable2_Boolfalse {
            public value: boolean;
            public next: zpp_nape.util.Hashable2_Boolfalse;
            public hnext: zpp_nape.util.Hashable2_Boolfalse;
            public id: number;
            public di: number;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.util.Hashable2_Boolfalse;
            public static get: (id: number, di: number, val: boolean) => zpp_nape.util.Hashable2_Boolfalse;
            public static getpersist: (id: number, di: number) => zpp_nape.util.Hashable2_Boolfalse;
            public static ordered_get: (id: number, di: number, val: boolean) => zpp_nape.util.Hashable2_Boolfalse;
            public static ordered_get_persist: (id: number, di: number) => zpp_nape.util.Hashable2_Boolfalse;
        }
        export class FastHash2_Hashable2_Boolfalse {
            public table: zpp_nape.util.Hashable2_Boolfalse[];
            public cnt: number;
            public empty: () => boolean;
            public get: (id: number, di: number) => zpp_nape.util.Hashable2_Boolfalse;
            public ordered_get: (id: number, di: number) => zpp_nape.util.Hashable2_Boolfalse;
            public hash: (id: number, di: number) => number;
            public clear(): void;
            public has(id: number, di: number): boolean;
            public maybeAdd(arb: zpp_nape.util.Hashable2_Boolfalse): void;
            public add(arb: zpp_nape.util.Hashable2_Boolfalse): void;
            public remove(arb: zpp_nape.util.Hashable2_Boolfalse): void;
            constructor();
        }
        export class ZNPList_ZPP_CallbackSet {
            public head: zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_CallbackSet) => void;
            public inlined_add: (o: zpp_nape.space.ZPP_CallbackSet) => zpp_nape.space.ZPP_CallbackSet;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_CallbackSet, o: zpp_nape.space.ZPP_CallbackSet) => zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.space.ZPP_CallbackSet;
            public inlined_remove: (obj: zpp_nape.space.ZPP_CallbackSet) => void;
            public inlined_try_remove: (obj: zpp_nape.space.ZPP_CallbackSet) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_CallbackSet) => zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.space.ZPP_CallbackSet) => boolean;
            public front: () => zpp_nape.space.ZPP_CallbackSet;
            public add(o: zpp_nape.space.ZPP_CallbackSet): zpp_nape.space.ZPP_CallbackSet;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_CallbackSet): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_CallbackSet, o: zpp_nape.space.ZPP_CallbackSet): zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public pop(): void;
            public pop_unsafe(): zpp_nape.space.ZPP_CallbackSet;
            public remove(obj: zpp_nape.space.ZPP_CallbackSet): void;
            public try_remove(obj: zpp_nape.space.ZPP_CallbackSet): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_CallbackSet): zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_CallbackSet, n: number): zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.space.ZPP_CallbackSet): boolean;
            public back(): zpp_nape.space.ZPP_CallbackSet;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public at(ind: number): zpp_nape.space.ZPP_CallbackSet;
            constructor();
        }
        export class ZNPList_ZPP_Shape {
            public head: zpp_nape.util.ZNPNode_ZPP_Shape;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Shape;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Shape) => void;
            public inlined_add: (o: zpp_nape.shape.ZPP_Shape) => zpp_nape.shape.ZPP_Shape;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Shape, o: zpp_nape.shape.ZPP_Shape) => zpp_nape.util.ZNPNode_ZPP_Shape;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.shape.ZPP_Shape;
            public inlined_remove: (obj: zpp_nape.shape.ZPP_Shape) => void;
            public inlined_try_remove: (obj: zpp_nape.shape.ZPP_Shape) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Shape) => zpp_nape.util.ZNPNode_ZPP_Shape;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.shape.ZPP_Shape) => boolean;
            public front: () => zpp_nape.shape.ZPP_Shape;
            public add(o: zpp_nape.shape.ZPP_Shape): zpp_nape.shape.ZPP_Shape;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Shape): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Shape, o: zpp_nape.shape.ZPP_Shape): zpp_nape.util.ZNPNode_ZPP_Shape;
            public pop(): void;
            public pop_unsafe(): zpp_nape.shape.ZPP_Shape;
            public remove(obj: zpp_nape.shape.ZPP_Shape): void;
            public try_remove(obj: zpp_nape.shape.ZPP_Shape): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Shape): zpp_nape.util.ZNPNode_ZPP_Shape;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Shape, n: number): zpp_nape.util.ZNPNode_ZPP_Shape;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.shape.ZPP_Shape): boolean;
            public back(): zpp_nape.shape.ZPP_Shape;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Shape;
            public at(ind: number): zpp_nape.shape.ZPP_Shape;
            constructor();
        }
        export class ZNPList_ZPP_Body {
            public head: zpp_nape.util.ZNPNode_ZPP_Body;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Body;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Body) => void;
            public inlined_add: (o: zpp_nape.phys.ZPP_Body) => zpp_nape.phys.ZPP_Body;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Body, o: zpp_nape.phys.ZPP_Body) => zpp_nape.util.ZNPNode_ZPP_Body;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.phys.ZPP_Body;
            public inlined_remove: (obj: zpp_nape.phys.ZPP_Body) => void;
            public inlined_try_remove: (obj: zpp_nape.phys.ZPP_Body) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Body) => zpp_nape.util.ZNPNode_ZPP_Body;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.phys.ZPP_Body) => boolean;
            public front: () => zpp_nape.phys.ZPP_Body;
            public add(o: zpp_nape.phys.ZPP_Body): zpp_nape.phys.ZPP_Body;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Body): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Body, o: zpp_nape.phys.ZPP_Body): zpp_nape.util.ZNPNode_ZPP_Body;
            public pop(): void;
            public pop_unsafe(): zpp_nape.phys.ZPP_Body;
            public remove(obj: zpp_nape.phys.ZPP_Body): void;
            public try_remove(obj: zpp_nape.phys.ZPP_Body): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Body): zpp_nape.util.ZNPNode_ZPP_Body;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Body, n: number): zpp_nape.util.ZNPNode_ZPP_Body;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.phys.ZPP_Body): boolean;
            public back(): zpp_nape.phys.ZPP_Body;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Body;
            public at(ind: number): zpp_nape.phys.ZPP_Body;
            constructor();
        }
        export class ZNPList_ZPP_Compound {
            public head: zpp_nape.util.ZNPNode_ZPP_Compound;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Compound;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Compound) => void;
            public inlined_add: (o: zpp_nape.phys.ZPP_Compound) => zpp_nape.phys.ZPP_Compound;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Compound, o: zpp_nape.phys.ZPP_Compound) => zpp_nape.util.ZNPNode_ZPP_Compound;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.phys.ZPP_Compound;
            public inlined_remove: (obj: zpp_nape.phys.ZPP_Compound) => void;
            public inlined_try_remove: (obj: zpp_nape.phys.ZPP_Compound) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Compound) => zpp_nape.util.ZNPNode_ZPP_Compound;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.phys.ZPP_Compound) => boolean;
            public front: () => zpp_nape.phys.ZPP_Compound;
            public add(o: zpp_nape.phys.ZPP_Compound): zpp_nape.phys.ZPP_Compound;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Compound): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Compound, o: zpp_nape.phys.ZPP_Compound): zpp_nape.util.ZNPNode_ZPP_Compound;
            public pop(): void;
            public pop_unsafe(): zpp_nape.phys.ZPP_Compound;
            public remove(obj: zpp_nape.phys.ZPP_Compound): void;
            public try_remove(obj: zpp_nape.phys.ZPP_Compound): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Compound): zpp_nape.util.ZNPNode_ZPP_Compound;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Compound, n: number): zpp_nape.util.ZNPNode_ZPP_Compound;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.phys.ZPP_Compound): boolean;
            public back(): zpp_nape.phys.ZPP_Compound;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Compound;
            public at(ind: number): zpp_nape.phys.ZPP_Compound;
            constructor();
        }
        export class ZNPList_ZPP_Arbiter {
            public head: zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Arbiter) => void;
            public inlined_add: (o: zpp_nape.dynamics.ZPP_Arbiter) => zpp_nape.dynamics.ZPP_Arbiter;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Arbiter, o: zpp_nape.dynamics.ZPP_Arbiter) => zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.dynamics.ZPP_Arbiter;
            public inlined_remove: (obj: zpp_nape.dynamics.ZPP_Arbiter) => void;
            public inlined_try_remove: (obj: zpp_nape.dynamics.ZPP_Arbiter) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Arbiter) => zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.dynamics.ZPP_Arbiter) => boolean;
            public front: () => zpp_nape.dynamics.ZPP_Arbiter;
            public add(o: zpp_nape.dynamics.ZPP_Arbiter): zpp_nape.dynamics.ZPP_Arbiter;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Arbiter): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Arbiter, o: zpp_nape.dynamics.ZPP_Arbiter): zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public pop(): void;
            public pop_unsafe(): zpp_nape.dynamics.ZPP_Arbiter;
            public remove(obj: zpp_nape.dynamics.ZPP_Arbiter): void;
            public try_remove(obj: zpp_nape.dynamics.ZPP_Arbiter): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Arbiter): zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Arbiter, n: number): zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.dynamics.ZPP_Arbiter): boolean;
            public back(): zpp_nape.dynamics.ZPP_Arbiter;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public at(ind: number): zpp_nape.dynamics.ZPP_Arbiter;
            constructor();
        }
        export class ZNPList_ZPP_CbSetPair {
            public head: zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_CbSetPair) => void;
            public inlined_add: (o: zpp_nape.callbacks.ZPP_CbSetPair) => zpp_nape.callbacks.ZPP_CbSetPair;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_CbSetPair, o: zpp_nape.callbacks.ZPP_CbSetPair) => zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.callbacks.ZPP_CbSetPair;
            public inlined_remove: (obj: zpp_nape.callbacks.ZPP_CbSetPair) => void;
            public inlined_try_remove: (obj: zpp_nape.callbacks.ZPP_CbSetPair) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_CbSetPair) => zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.callbacks.ZPP_CbSetPair) => boolean;
            public front: () => zpp_nape.callbacks.ZPP_CbSetPair;
            public add(o: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.callbacks.ZPP_CbSetPair;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_CbSetPair): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_CbSetPair, o: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public pop(): void;
            public pop_unsafe(): zpp_nape.callbacks.ZPP_CbSetPair;
            public remove(obj: zpp_nape.callbacks.ZPP_CbSetPair): void;
            public try_remove(obj: zpp_nape.callbacks.ZPP_CbSetPair): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_CbSetPair): zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_CbSetPair, n: number): zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.callbacks.ZPP_CbSetPair): boolean;
            public back(): zpp_nape.callbacks.ZPP_CbSetPair;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public at(ind: number): zpp_nape.callbacks.ZPP_CbSetPair;
            constructor();
        }
        export class ZNPList_ZPP_CutInt {
            public head: zpp_nape.util.ZNPNode_ZPP_CutInt;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_CutInt;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_CutInt) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_CutInt) => zpp_nape.geom.ZPP_CutInt;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_CutInt, o: zpp_nape.geom.ZPP_CutInt) => zpp_nape.util.ZNPNode_ZPP_CutInt;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_CutInt;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_CutInt) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_CutInt) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_CutInt) => zpp_nape.util.ZNPNode_ZPP_CutInt;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_CutInt) => boolean;
            public front: () => zpp_nape.geom.ZPP_CutInt;
            public add(o: zpp_nape.geom.ZPP_CutInt): zpp_nape.geom.ZPP_CutInt;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_CutInt): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_CutInt, o: zpp_nape.geom.ZPP_CutInt): zpp_nape.util.ZNPNode_ZPP_CutInt;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_CutInt;
            public remove(obj: zpp_nape.geom.ZPP_CutInt): void;
            public try_remove(obj: zpp_nape.geom.ZPP_CutInt): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_CutInt): zpp_nape.util.ZNPNode_ZPP_CutInt;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_CutInt, n: number): zpp_nape.util.ZNPNode_ZPP_CutInt;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_CutInt): boolean;
            public back(): zpp_nape.geom.ZPP_CutInt;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_CutInt;
            public at(ind: number): zpp_nape.geom.ZPP_CutInt;
            constructor();
        }
        export class ZNPList_ZPP_CutVert {
            public head: zpp_nape.util.ZNPNode_ZPP_CutVert;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_CutVert;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_CutVert) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_CutVert) => zpp_nape.geom.ZPP_CutVert;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_CutVert, o: zpp_nape.geom.ZPP_CutVert) => zpp_nape.util.ZNPNode_ZPP_CutVert;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_CutVert;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_CutVert) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_CutVert) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_CutVert) => zpp_nape.util.ZNPNode_ZPP_CutVert;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_CutVert) => boolean;
            public front: () => zpp_nape.geom.ZPP_CutVert;
            public add(o: zpp_nape.geom.ZPP_CutVert): zpp_nape.geom.ZPP_CutVert;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_CutVert): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_CutVert, o: zpp_nape.geom.ZPP_CutVert): zpp_nape.util.ZNPNode_ZPP_CutVert;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_CutVert;
            public remove(obj: zpp_nape.geom.ZPP_CutVert): void;
            public try_remove(obj: zpp_nape.geom.ZPP_CutVert): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_CutVert): zpp_nape.util.ZNPNode_ZPP_CutVert;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_CutVert, n: number): zpp_nape.util.ZNPNode_ZPP_CutVert;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_CutVert): boolean;
            public back(): zpp_nape.geom.ZPP_CutVert;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_CutVert;
            public at(ind: number): zpp_nape.geom.ZPP_CutVert;
            constructor();
        }
        export class ZNPList_ZPP_PartitionVertex {
            public head: zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_PartitionVertex) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_PartitionVertex) => zpp_nape.geom.ZPP_PartitionVertex;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_PartitionVertex, o: zpp_nape.geom.ZPP_PartitionVertex) => zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_PartitionVertex;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_PartitionVertex) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_PartitionVertex) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_PartitionVertex) => zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_PartitionVertex) => boolean;
            public front: () => zpp_nape.geom.ZPP_PartitionVertex;
            public add(o: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.geom.ZPP_PartitionVertex;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_PartitionVertex): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_PartitionVertex, o: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_PartitionVertex;
            public remove(obj: zpp_nape.geom.ZPP_PartitionVertex): void;
            public try_remove(obj: zpp_nape.geom.ZPP_PartitionVertex): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_PartitionVertex): zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_PartitionVertex, n: number): zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_PartitionVertex): boolean;
            public back(): zpp_nape.geom.ZPP_PartitionVertex;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public at(ind: number): zpp_nape.geom.ZPP_PartitionVertex;
            constructor();
        }
        export class ZNPList_ZPP_SimplifyP {
            public head: zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_SimplifyP) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_SimplifyP) => zpp_nape.geom.ZPP_SimplifyP;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_SimplifyP, o: zpp_nape.geom.ZPP_SimplifyP) => zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_SimplifyP;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_SimplifyP) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_SimplifyP) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_SimplifyP) => zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_SimplifyP) => boolean;
            public front: () => zpp_nape.geom.ZPP_SimplifyP;
            public add(o: zpp_nape.geom.ZPP_SimplifyP): zpp_nape.geom.ZPP_SimplifyP;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_SimplifyP): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_SimplifyP, o: zpp_nape.geom.ZPP_SimplifyP): zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_SimplifyP;
            public remove(obj: zpp_nape.geom.ZPP_SimplifyP): void;
            public try_remove(obj: zpp_nape.geom.ZPP_SimplifyP): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_SimplifyP): zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_SimplifyP, n: number): zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_SimplifyP): boolean;
            public back(): zpp_nape.geom.ZPP_SimplifyP;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public at(ind: number): zpp_nape.geom.ZPP_SimplifyP;
            constructor();
        }
        export class ZNPList_ZPP_PartitionedPoly {
            public head: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_PartitionedPoly) => zpp_nape.geom.ZPP_PartitionedPoly;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly, o: zpp_nape.geom.ZPP_PartitionedPoly) => zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_PartitionedPoly;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_PartitionedPoly) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_PartitionedPoly) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly) => zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_PartitionedPoly) => boolean;
            public front: () => zpp_nape.geom.ZPP_PartitionedPoly;
            public add(o: zpp_nape.geom.ZPP_PartitionedPoly): zpp_nape.geom.ZPP_PartitionedPoly;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_PartitionedPoly): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly, o: zpp_nape.geom.ZPP_PartitionedPoly): zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_PartitionedPoly;
            public remove(obj: zpp_nape.geom.ZPP_PartitionedPoly): void;
            public try_remove(obj: zpp_nape.geom.ZPP_PartitionedPoly): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly): zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly, n: number): zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_PartitionedPoly): boolean;
            public back(): zpp_nape.geom.ZPP_PartitionedPoly;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public at(ind: number): zpp_nape.geom.ZPP_PartitionedPoly;
            constructor();
        }
        export class ZNPList_ZPP_GeomVert {
            public head: zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_GeomVert) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_GeomVert) => zpp_nape.geom.ZPP_GeomVert;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_GeomVert, o: zpp_nape.geom.ZPP_GeomVert) => zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_GeomVert;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_GeomVert) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_GeomVert) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_GeomVert) => zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_GeomVert) => boolean;
            public front: () => zpp_nape.geom.ZPP_GeomVert;
            public add(o: zpp_nape.geom.ZPP_GeomVert): zpp_nape.geom.ZPP_GeomVert;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_GeomVert): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_GeomVert, o: zpp_nape.geom.ZPP_GeomVert): zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_GeomVert;
            public remove(obj: zpp_nape.geom.ZPP_GeomVert): void;
            public try_remove(obj: zpp_nape.geom.ZPP_GeomVert): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_GeomVert): zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_GeomVert, n: number): zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_GeomVert): boolean;
            public back(): zpp_nape.geom.ZPP_GeomVert;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public at(ind: number): zpp_nape.geom.ZPP_GeomVert;
            constructor();
        }
        export class ZNPList_ZPP_SimpleVert {
            public head: zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_SimpleVert) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_SimpleVert) => zpp_nape.geom.ZPP_SimpleVert;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_SimpleVert, o: zpp_nape.geom.ZPP_SimpleVert) => zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_SimpleVert;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_SimpleVert) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_SimpleVert) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_SimpleVert) => zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_SimpleVert) => boolean;
            public front: () => zpp_nape.geom.ZPP_SimpleVert;
            public add(o: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.geom.ZPP_SimpleVert;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_SimpleVert): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_SimpleVert, o: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_SimpleVert;
            public remove(obj: zpp_nape.geom.ZPP_SimpleVert): void;
            public try_remove(obj: zpp_nape.geom.ZPP_SimpleVert): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_SimpleVert): zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_SimpleVert, n: number): zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_SimpleVert): boolean;
            public back(): zpp_nape.geom.ZPP_SimpleVert;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public at(ind: number): zpp_nape.geom.ZPP_SimpleVert;
            constructor();
        }
        export class ZNPList_ZPP_SimpleEvent {
            public head: zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_SimpleEvent) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_SimpleEvent) => zpp_nape.geom.ZPP_SimpleEvent;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_SimpleEvent, o: zpp_nape.geom.ZPP_SimpleEvent) => zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_SimpleEvent;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_SimpleEvent) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_SimpleEvent) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_SimpleEvent) => zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_SimpleEvent) => boolean;
            public front: () => zpp_nape.geom.ZPP_SimpleEvent;
            public add(o: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.geom.ZPP_SimpleEvent;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_SimpleEvent): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_SimpleEvent, o: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_SimpleEvent;
            public remove(obj: zpp_nape.geom.ZPP_SimpleEvent): void;
            public try_remove(obj: zpp_nape.geom.ZPP_SimpleEvent): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_SimpleEvent): zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_SimpleEvent, n: number): zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_SimpleEvent): boolean;
            public back(): zpp_nape.geom.ZPP_SimpleEvent;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public at(ind: number): zpp_nape.geom.ZPP_SimpleEvent;
            constructor();
        }
        export class ZNPList_ZPP_AABBPair {
            public head: zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_AABBPair) => void;
            public inlined_add: (o: zpp_nape.space.ZPP_AABBPair) => zpp_nape.space.ZPP_AABBPair;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_AABBPair, o: zpp_nape.space.ZPP_AABBPair) => zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.space.ZPP_AABBPair;
            public inlined_remove: (obj: zpp_nape.space.ZPP_AABBPair) => void;
            public inlined_try_remove: (obj: zpp_nape.space.ZPP_AABBPair) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_AABBPair) => zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.space.ZPP_AABBPair) => boolean;
            public front: () => zpp_nape.space.ZPP_AABBPair;
            public add(o: zpp_nape.space.ZPP_AABBPair): zpp_nape.space.ZPP_AABBPair;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_AABBPair): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_AABBPair, o: zpp_nape.space.ZPP_AABBPair): zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public pop(): void;
            public pop_unsafe(): zpp_nape.space.ZPP_AABBPair;
            public remove(obj: zpp_nape.space.ZPP_AABBPair): void;
            public try_remove(obj: zpp_nape.space.ZPP_AABBPair): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_AABBPair): zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_AABBPair, n: number): zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.space.ZPP_AABBPair): boolean;
            public back(): zpp_nape.space.ZPP_AABBPair;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public at(ind: number): zpp_nape.space.ZPP_AABBPair;
            constructor();
        }
        export class ZNPList_ZPP_Edge {
            public head: zpp_nape.util.ZNPNode_ZPP_Edge;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Edge;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Edge) => void;
            public inlined_add: (o: zpp_nape.shape.ZPP_Edge) => zpp_nape.shape.ZPP_Edge;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Edge, o: zpp_nape.shape.ZPP_Edge) => zpp_nape.util.ZNPNode_ZPP_Edge;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.shape.ZPP_Edge;
            public inlined_remove: (obj: zpp_nape.shape.ZPP_Edge) => void;
            public inlined_try_remove: (obj: zpp_nape.shape.ZPP_Edge) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Edge) => zpp_nape.util.ZNPNode_ZPP_Edge;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.shape.ZPP_Edge) => boolean;
            public front: () => zpp_nape.shape.ZPP_Edge;
            public add(o: zpp_nape.shape.ZPP_Edge): zpp_nape.shape.ZPP_Edge;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Edge): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Edge, o: zpp_nape.shape.ZPP_Edge): zpp_nape.util.ZNPNode_ZPP_Edge;
            public pop(): void;
            public pop_unsafe(): zpp_nape.shape.ZPP_Edge;
            public remove(obj: zpp_nape.shape.ZPP_Edge): void;
            public try_remove(obj: zpp_nape.shape.ZPP_Edge): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Edge): zpp_nape.util.ZNPNode_ZPP_Edge;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Edge, n: number): zpp_nape.util.ZNPNode_ZPP_Edge;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.shape.ZPP_Edge): boolean;
            public back(): zpp_nape.shape.ZPP_Edge;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Edge;
            public at(ind: number): zpp_nape.shape.ZPP_Edge;
            constructor();
        }
        export class ZNPList_ZPP_AABBNode {
            public head: zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_AABBNode) => void;
            public inlined_add: (o: zpp_nape.space.ZPP_AABBNode) => zpp_nape.space.ZPP_AABBNode;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_AABBNode, o: zpp_nape.space.ZPP_AABBNode) => zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.space.ZPP_AABBNode;
            public inlined_remove: (obj: zpp_nape.space.ZPP_AABBNode) => void;
            public inlined_try_remove: (obj: zpp_nape.space.ZPP_AABBNode) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_AABBNode) => zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.space.ZPP_AABBNode) => boolean;
            public front: () => zpp_nape.space.ZPP_AABBNode;
            public add(o: zpp_nape.space.ZPP_AABBNode): zpp_nape.space.ZPP_AABBNode;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_AABBNode): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_AABBNode, o: zpp_nape.space.ZPP_AABBNode): zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public pop(): void;
            public pop_unsafe(): zpp_nape.space.ZPP_AABBNode;
            public remove(obj: zpp_nape.space.ZPP_AABBNode): void;
            public try_remove(obj: zpp_nape.space.ZPP_AABBNode): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_AABBNode): zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_AABBNode, n: number): zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.space.ZPP_AABBNode): boolean;
            public back(): zpp_nape.space.ZPP_AABBNode;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public at(ind: number): zpp_nape.space.ZPP_AABBNode;
            constructor();
        }
        export class ZNPList_ZPP_Component {
            public head: zpp_nape.util.ZNPNode_ZPP_Component;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Component;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Component) => void;
            public inlined_add: (o: zpp_nape.space.ZPP_Component) => zpp_nape.space.ZPP_Component;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Component, o: zpp_nape.space.ZPP_Component) => zpp_nape.util.ZNPNode_ZPP_Component;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.space.ZPP_Component;
            public inlined_remove: (obj: zpp_nape.space.ZPP_Component) => void;
            public inlined_try_remove: (obj: zpp_nape.space.ZPP_Component) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Component) => zpp_nape.util.ZNPNode_ZPP_Component;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.space.ZPP_Component) => boolean;
            public front: () => zpp_nape.space.ZPP_Component;
            public add(o: zpp_nape.space.ZPP_Component): zpp_nape.space.ZPP_Component;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Component): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Component, o: zpp_nape.space.ZPP_Component): zpp_nape.util.ZNPNode_ZPP_Component;
            public pop(): void;
            public pop_unsafe(): zpp_nape.space.ZPP_Component;
            public remove(obj: zpp_nape.space.ZPP_Component): void;
            public try_remove(obj: zpp_nape.space.ZPP_Component): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Component): zpp_nape.util.ZNPNode_ZPP_Component;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Component, n: number): zpp_nape.util.ZNPNode_ZPP_Component;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.space.ZPP_Component): boolean;
            public back(): zpp_nape.space.ZPP_Component;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Component;
            public at(ind: number): zpp_nape.space.ZPP_Component;
            constructor();
        }
        export class ZNPList_ZPP_FluidArbiter {
            public head: zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_FluidArbiter) => void;
            public inlined_add: (o: zpp_nape.dynamics.ZPP_FluidArbiter) => zpp_nape.dynamics.ZPP_FluidArbiter;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_FluidArbiter, o: zpp_nape.dynamics.ZPP_FluidArbiter) => zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.dynamics.ZPP_FluidArbiter;
            public inlined_remove: (obj: zpp_nape.dynamics.ZPP_FluidArbiter) => void;
            public inlined_try_remove: (obj: zpp_nape.dynamics.ZPP_FluidArbiter) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_FluidArbiter) => zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.dynamics.ZPP_FluidArbiter) => boolean;
            public front: () => zpp_nape.dynamics.ZPP_FluidArbiter;
            public add(o: zpp_nape.dynamics.ZPP_FluidArbiter): zpp_nape.dynamics.ZPP_FluidArbiter;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_FluidArbiter): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_FluidArbiter, o: zpp_nape.dynamics.ZPP_FluidArbiter): zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public pop(): void;
            public pop_unsafe(): zpp_nape.dynamics.ZPP_FluidArbiter;
            public remove(obj: zpp_nape.dynamics.ZPP_FluidArbiter): void;
            public try_remove(obj: zpp_nape.dynamics.ZPP_FluidArbiter): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_FluidArbiter): zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_FluidArbiter, n: number): zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.dynamics.ZPP_FluidArbiter): boolean;
            public back(): zpp_nape.dynamics.ZPP_FluidArbiter;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public at(ind: number): zpp_nape.dynamics.ZPP_FluidArbiter;
            constructor();
        }
        export class ZNPList_ZPP_SensorArbiter {
            public head: zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_SensorArbiter) => void;
            public inlined_add: (o: zpp_nape.dynamics.ZPP_SensorArbiter) => zpp_nape.dynamics.ZPP_SensorArbiter;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_SensorArbiter, o: zpp_nape.dynamics.ZPP_SensorArbiter) => zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.dynamics.ZPP_SensorArbiter;
            public inlined_remove: (obj: zpp_nape.dynamics.ZPP_SensorArbiter) => void;
            public inlined_try_remove: (obj: zpp_nape.dynamics.ZPP_SensorArbiter) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_SensorArbiter) => zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.dynamics.ZPP_SensorArbiter) => boolean;
            public front: () => zpp_nape.dynamics.ZPP_SensorArbiter;
            public add(o: zpp_nape.dynamics.ZPP_SensorArbiter): zpp_nape.dynamics.ZPP_SensorArbiter;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_SensorArbiter): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_SensorArbiter, o: zpp_nape.dynamics.ZPP_SensorArbiter): zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public pop(): void;
            public pop_unsafe(): zpp_nape.dynamics.ZPP_SensorArbiter;
            public remove(obj: zpp_nape.dynamics.ZPP_SensorArbiter): void;
            public try_remove(obj: zpp_nape.dynamics.ZPP_SensorArbiter): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_SensorArbiter): zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_SensorArbiter, n: number): zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.dynamics.ZPP_SensorArbiter): boolean;
            public back(): zpp_nape.dynamics.ZPP_SensorArbiter;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public at(ind: number): zpp_nape.dynamics.ZPP_SensorArbiter;
            constructor();
        }
        export class ZNPList_ZPP_Listener {
            public head: zpp_nape.util.ZNPNode_ZPP_Listener;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_Listener;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_Listener) => void;
            public inlined_add: (o: zpp_nape.callbacks.ZPP_Listener) => zpp_nape.callbacks.ZPP_Listener;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_Listener, o: zpp_nape.callbacks.ZPP_Listener) => zpp_nape.util.ZNPNode_ZPP_Listener;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.callbacks.ZPP_Listener;
            public inlined_remove: (obj: zpp_nape.callbacks.ZPP_Listener) => void;
            public inlined_try_remove: (obj: zpp_nape.callbacks.ZPP_Listener) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_Listener) => zpp_nape.util.ZNPNode_ZPP_Listener;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.callbacks.ZPP_Listener) => boolean;
            public front: () => zpp_nape.callbacks.ZPP_Listener;
            public add(o: zpp_nape.callbacks.ZPP_Listener): zpp_nape.callbacks.ZPP_Listener;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_Listener): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_Listener, o: zpp_nape.callbacks.ZPP_Listener): zpp_nape.util.ZNPNode_ZPP_Listener;
            public pop(): void;
            public pop_unsafe(): zpp_nape.callbacks.ZPP_Listener;
            public remove(obj: zpp_nape.callbacks.ZPP_Listener): void;
            public try_remove(obj: zpp_nape.callbacks.ZPP_Listener): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_Listener): zpp_nape.util.ZNPNode_ZPP_Listener;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_Listener, n: number): zpp_nape.util.ZNPNode_ZPP_Listener;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.callbacks.ZPP_Listener): boolean;
            public back(): zpp_nape.callbacks.ZPP_Listener;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_Listener;
            public at(ind: number): zpp_nape.callbacks.ZPP_Listener;
            constructor();
        }
        export class ZNPList_ZPP_ColArbiter {
            public head: zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_ColArbiter) => void;
            public inlined_add: (o: zpp_nape.dynamics.ZPP_ColArbiter) => zpp_nape.dynamics.ZPP_ColArbiter;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_ColArbiter, o: zpp_nape.dynamics.ZPP_ColArbiter) => zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.dynamics.ZPP_ColArbiter;
            public inlined_remove: (obj: zpp_nape.dynamics.ZPP_ColArbiter) => void;
            public inlined_try_remove: (obj: zpp_nape.dynamics.ZPP_ColArbiter) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_ColArbiter) => zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.dynamics.ZPP_ColArbiter) => boolean;
            public front: () => zpp_nape.dynamics.ZPP_ColArbiter;
            public add(o: zpp_nape.dynamics.ZPP_ColArbiter): zpp_nape.dynamics.ZPP_ColArbiter;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_ColArbiter): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_ColArbiter, o: zpp_nape.dynamics.ZPP_ColArbiter): zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public pop(): void;
            public pop_unsafe(): zpp_nape.dynamics.ZPP_ColArbiter;
            public remove(obj: zpp_nape.dynamics.ZPP_ColArbiter): void;
            public try_remove(obj: zpp_nape.dynamics.ZPP_ColArbiter): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_ColArbiter): zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_ColArbiter, n: number): zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.dynamics.ZPP_ColArbiter): boolean;
            public back(): zpp_nape.dynamics.ZPP_ColArbiter;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public at(ind: number): zpp_nape.dynamics.ZPP_ColArbiter;
            constructor();
        }
        export class ZNPList_ZPP_InteractionGroup {
            public head: zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_InteractionGroup) => void;
            public inlined_add: (o: zpp_nape.dynamics.ZPP_InteractionGroup) => zpp_nape.dynamics.ZPP_InteractionGroup;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_InteractionGroup, o: zpp_nape.dynamics.ZPP_InteractionGroup) => zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.dynamics.ZPP_InteractionGroup;
            public inlined_remove: (obj: zpp_nape.dynamics.ZPP_InteractionGroup) => void;
            public inlined_try_remove: (obj: zpp_nape.dynamics.ZPP_InteractionGroup) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_InteractionGroup) => zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.dynamics.ZPP_InteractionGroup) => boolean;
            public front: () => zpp_nape.dynamics.ZPP_InteractionGroup;
            public add(o: zpp_nape.dynamics.ZPP_InteractionGroup): zpp_nape.dynamics.ZPP_InteractionGroup;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_InteractionGroup): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_InteractionGroup, o: zpp_nape.dynamics.ZPP_InteractionGroup): zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public pop(): void;
            public pop_unsafe(): zpp_nape.dynamics.ZPP_InteractionGroup;
            public remove(obj: zpp_nape.dynamics.ZPP_InteractionGroup): void;
            public try_remove(obj: zpp_nape.dynamics.ZPP_InteractionGroup): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_InteractionGroup): zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_InteractionGroup, n: number): zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.dynamics.ZPP_InteractionGroup): boolean;
            public back(): zpp_nape.dynamics.ZPP_InteractionGroup;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public at(ind: number): zpp_nape.dynamics.ZPP_InteractionGroup;
            constructor();
        }
        export class ZNPList_ZPP_ToiEvent {
            public head: zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_ToiEvent) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_ToiEvent) => zpp_nape.geom.ZPP_ToiEvent;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_ToiEvent, o: zpp_nape.geom.ZPP_ToiEvent) => zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_ToiEvent;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_ToiEvent) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_ToiEvent) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_ToiEvent) => zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_ToiEvent) => boolean;
            public front: () => zpp_nape.geom.ZPP_ToiEvent;
            public add(o: zpp_nape.geom.ZPP_ToiEvent): zpp_nape.geom.ZPP_ToiEvent;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_ToiEvent): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_ToiEvent, o: zpp_nape.geom.ZPP_ToiEvent): zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_ToiEvent;
            public remove(obj: zpp_nape.geom.ZPP_ToiEvent): void;
            public try_remove(obj: zpp_nape.geom.ZPP_ToiEvent): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_ToiEvent): zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_ToiEvent, n: number): zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_ToiEvent): boolean;
            public back(): zpp_nape.geom.ZPP_ToiEvent;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public at(ind: number): zpp_nape.geom.ZPP_ToiEvent;
            constructor();
        }
        export class ZNPList_ConvexResult {
            public head: zpp_nape.util.ZNPNode_ConvexResult;
            public begin: () => zpp_nape.util.ZNPNode_ConvexResult;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ConvexResult) => void;
            public inlined_add: (o: nape.geom.ConvexResult) => nape.geom.ConvexResult;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ConvexResult, o: nape.geom.ConvexResult) => zpp_nape.util.ZNPNode_ConvexResult;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => nape.geom.ConvexResult;
            public inlined_remove: (obj: nape.geom.ConvexResult) => void;
            public inlined_try_remove: (obj: nape.geom.ConvexResult) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ConvexResult) => zpp_nape.util.ZNPNode_ConvexResult;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: nape.geom.ConvexResult) => boolean;
            public front: () => nape.geom.ConvexResult;
            public add(o: nape.geom.ConvexResult): nape.geom.ConvexResult;
            public addAll(x: zpp_nape.util.ZNPList_ConvexResult): void;
            public insert(cur: zpp_nape.util.ZNPNode_ConvexResult, o: nape.geom.ConvexResult): zpp_nape.util.ZNPNode_ConvexResult;
            public pop(): void;
            public pop_unsafe(): nape.geom.ConvexResult;
            public remove(obj: nape.geom.ConvexResult): void;
            public try_remove(obj: nape.geom.ConvexResult): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ConvexResult): zpp_nape.util.ZNPNode_ConvexResult;
            public splice(pre: zpp_nape.util.ZNPNode_ConvexResult, n: number): zpp_nape.util.ZNPNode_ConvexResult;
            public clear(): void;
            public reverse(): void;
            public has(obj: nape.geom.ConvexResult): boolean;
            public back(): nape.geom.ConvexResult;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ConvexResult;
            public at(ind: number): nape.geom.ConvexResult;
            constructor();
        }
        export class ZNPList_ZPP_GeomPoly {
            public head: zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public begin: () => zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_ZPP_GeomPoly) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_GeomPoly) => zpp_nape.geom.ZPP_GeomPoly;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_ZPP_GeomPoly, o: zpp_nape.geom.ZPP_GeomPoly) => zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_GeomPoly;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_GeomPoly) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_GeomPoly) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_ZPP_GeomPoly) => zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_GeomPoly) => boolean;
            public front: () => zpp_nape.geom.ZPP_GeomPoly;
            public add(o: zpp_nape.geom.ZPP_GeomPoly): zpp_nape.geom.ZPP_GeomPoly;
            public addAll(x: zpp_nape.util.ZNPList_ZPP_GeomPoly): void;
            public insert(cur: zpp_nape.util.ZNPNode_ZPP_GeomPoly, o: zpp_nape.geom.ZPP_GeomPoly): zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_GeomPoly;
            public remove(obj: zpp_nape.geom.ZPP_GeomPoly): void;
            public try_remove(obj: zpp_nape.geom.ZPP_GeomPoly): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_ZPP_GeomPoly): zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public splice(pre: zpp_nape.util.ZNPNode_ZPP_GeomPoly, n: number): zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_GeomPoly): boolean;
            public back(): zpp_nape.geom.ZPP_GeomPoly;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public at(ind: number): zpp_nape.geom.ZPP_GeomPoly;
            constructor();
        }
        export class ZNPList_RayResult {
            public head: zpp_nape.util.ZNPNode_RayResult;
            public begin: () => zpp_nape.util.ZNPNode_RayResult;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.util.ZNPNode_RayResult) => void;
            public inlined_add: (o: nape.geom.RayResult) => nape.geom.RayResult;
            public inlined_insert: (cur: zpp_nape.util.ZNPNode_RayResult, o: nape.geom.RayResult) => zpp_nape.util.ZNPNode_RayResult;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => nape.geom.RayResult;
            public inlined_remove: (obj: nape.geom.RayResult) => void;
            public inlined_try_remove: (obj: nape.geom.RayResult) => boolean;
            public inlined_erase: (pre: zpp_nape.util.ZNPNode_RayResult) => zpp_nape.util.ZNPNode_RayResult;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: nape.geom.RayResult) => boolean;
            public front: () => nape.geom.RayResult;
            public add(o: nape.geom.RayResult): nape.geom.RayResult;
            public addAll(x: zpp_nape.util.ZNPList_RayResult): void;
            public insert(cur: zpp_nape.util.ZNPNode_RayResult, o: nape.geom.RayResult): zpp_nape.util.ZNPNode_RayResult;
            public pop(): void;
            public pop_unsafe(): nape.geom.RayResult;
            public remove(obj: nape.geom.RayResult): void;
            public try_remove(obj: nape.geom.RayResult): boolean;
            public erase(pre: zpp_nape.util.ZNPNode_RayResult): zpp_nape.util.ZNPNode_RayResult;
            public splice(pre: zpp_nape.util.ZNPNode_RayResult, n: number): zpp_nape.util.ZNPNode_RayResult;
            public clear(): void;
            public reverse(): void;
            public has(obj: nape.geom.RayResult): boolean;
            public back(): nape.geom.RayResult;
            public iterator_at(ind: number): zpp_nape.util.ZNPNode_RayResult;
            public at(ind: number): nape.geom.RayResult;
            constructor();
        }
        export class ZNPNode_ZPP_CbType {
            public next: zpp_nape.util.ZNPNode_ZPP_CbType;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.callbacks.ZPP_CbType;
            public elem: () => zpp_nape.callbacks.ZPP_CbType;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_CbType;
            constructor();
        }
        export class ZNPNode_ZPP_CallbackSet {
            public next: zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.space.ZPP_CallbackSet;
            public elem: () => zpp_nape.space.ZPP_CallbackSet;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_CallbackSet;
            constructor();
        }
        export class ZNPNode_ZPP_Shape {
            public next: zpp_nape.util.ZNPNode_ZPP_Shape;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.shape.ZPP_Shape;
            public elem: () => zpp_nape.shape.ZPP_Shape;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Shape;
            constructor();
        }
        export class ZNPNode_ZPP_Body {
            public next: zpp_nape.util.ZNPNode_ZPP_Body;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.phys.ZPP_Body;
            public elem: () => zpp_nape.phys.ZPP_Body;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Body;
            constructor();
        }
        export class ZNPNode_ZPP_Constraint {
            public next: zpp_nape.util.ZNPNode_ZPP_Constraint;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.constraint.ZPP_Constraint;
            public elem: () => zpp_nape.constraint.ZPP_Constraint;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Constraint;
            constructor();
        }
        export class ZNPNode_ZPP_Compound {
            public next: zpp_nape.util.ZNPNode_ZPP_Compound;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.phys.ZPP_Compound;
            public elem: () => zpp_nape.phys.ZPP_Compound;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Compound;
            constructor();
        }
        export class ZNPNode_ZPP_Arbiter {
            public next: zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.dynamics.ZPP_Arbiter;
            public elem: () => zpp_nape.dynamics.ZPP_Arbiter;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Arbiter;
            constructor();
        }
        export class ZNPNode_ZPP_InteractionListener {
            public next: zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.callbacks.ZPP_InteractionListener;
            public elem: () => zpp_nape.callbacks.ZPP_InteractionListener;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_InteractionListener;
            constructor();
        }
        export class ZNPNode_ZPP_CbSet {
            public next: zpp_nape.util.ZNPNode_ZPP_CbSet;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.callbacks.ZPP_CbSet;
            public elem: () => zpp_nape.callbacks.ZPP_CbSet;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_CbSet;
            constructor();
        }
        export class ZNPNode_ZPP_Interactor {
            public next: zpp_nape.util.ZNPNode_ZPP_Interactor;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.phys.ZPP_Interactor;
            public elem: () => zpp_nape.phys.ZPP_Interactor;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Interactor;
            constructor();
        }
        export class ZNPNode_ZPP_BodyListener {
            public next: zpp_nape.util.ZNPNode_ZPP_BodyListener;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.callbacks.ZPP_BodyListener;
            public elem: () => zpp_nape.callbacks.ZPP_BodyListener;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_BodyListener;
            constructor();
        }
        export class ZNPNode_ZPP_CbSetPair {
            public next: zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.callbacks.ZPP_CbSetPair;
            public elem: () => zpp_nape.callbacks.ZPP_CbSetPair;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_CbSetPair;
            constructor();
        }
        export class ZNPNode_ZPP_ConstraintListener {
            public next: zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.callbacks.ZPP_ConstraintListener;
            public elem: () => zpp_nape.callbacks.ZPP_ConstraintListener;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_ConstraintListener;
            constructor();
        }
        export class ZNPNode_ZPP_CutInt {
            public next: zpp_nape.util.ZNPNode_ZPP_CutInt;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_CutInt;
            public elem: () => zpp_nape.geom.ZPP_CutInt;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_CutInt;
            constructor();
        }
        export class ZNPNode_ZPP_CutVert {
            public next: zpp_nape.util.ZNPNode_ZPP_CutVert;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_CutVert;
            public elem: () => zpp_nape.geom.ZPP_CutVert;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_CutVert;
            constructor();
        }
        export class ZNPNode_ZPP_PartitionVertex {
            public next: zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_PartitionVertex;
            public elem: () => zpp_nape.geom.ZPP_PartitionVertex;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_PartitionVertex;
            constructor();
        }
        export class ZNPNode_ZPP_SimplifyP {
            public next: zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_SimplifyP;
            public elem: () => zpp_nape.geom.ZPP_SimplifyP;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_SimplifyP;
            constructor();
        }
        export class ZNPNode_ZPP_PartitionedPoly {
            public next: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_PartitionedPoly;
            public elem: () => zpp_nape.geom.ZPP_PartitionedPoly;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_PartitionedPoly;
            constructor();
        }
        export class ZNPNode_ZPP_GeomVert {
            public next: zpp_nape.util.ZNPNode_ZPP_GeomVert;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_GeomVert;
            public elem: () => zpp_nape.geom.ZPP_GeomVert;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_GeomVert;
            constructor();
        }
        export class ZNPNode_ZPP_SimpleVert {
            public next: zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_SimpleVert;
            public elem: () => zpp_nape.geom.ZPP_SimpleVert;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_SimpleVert;
            constructor();
        }
        export class ZNPNode_ZPP_SimpleEvent {
            public next: zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_SimpleEvent;
            public elem: () => zpp_nape.geom.ZPP_SimpleEvent;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_SimpleEvent;
            constructor();
        }
        export class ZNPNode_ZPP_Vec2 {
            public next: zpp_nape.util.ZNPNode_ZPP_Vec2;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_Vec2;
            public elem: () => zpp_nape.geom.ZPP_Vec2;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Vec2;
            constructor();
        }
        export class ZNPNode_ZPP_AABBPair {
            public next: zpp_nape.util.ZNPNode_ZPP_AABBPair;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.space.ZPP_AABBPair;
            public elem: () => zpp_nape.space.ZPP_AABBPair;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_AABBPair;
            constructor();
        }
        export class ZNPNode_ZPP_Edge {
            public next: zpp_nape.util.ZNPNode_ZPP_Edge;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.shape.ZPP_Edge;
            public elem: () => zpp_nape.shape.ZPP_Edge;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Edge;
            constructor();
        }
        export class ZNPNode_ZPP_AABBNode {
            public next: zpp_nape.util.ZNPNode_ZPP_AABBNode;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.space.ZPP_AABBNode;
            public elem: () => zpp_nape.space.ZPP_AABBNode;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_AABBNode;
            constructor();
        }
        export class ZNPNode_ZPP_Component {
            public next: zpp_nape.util.ZNPNode_ZPP_Component;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.space.ZPP_Component;
            public elem: () => zpp_nape.space.ZPP_Component;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Component;
            constructor();
        }
        export class ZNPNode_ZPP_FluidArbiter {
            public next: zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.dynamics.ZPP_FluidArbiter;
            public elem: () => zpp_nape.dynamics.ZPP_FluidArbiter;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            constructor();
        }
        export class ZNPNode_ZPP_SensorArbiter {
            public next: zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.dynamics.ZPP_SensorArbiter;
            public elem: () => zpp_nape.dynamics.ZPP_SensorArbiter;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            constructor();
        }
        export class ZNPNode_ZPP_Listener {
            public next: zpp_nape.util.ZNPNode_ZPP_Listener;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.callbacks.ZPP_Listener;
            public elem: () => zpp_nape.callbacks.ZPP_Listener;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_Listener;
            constructor();
        }
        export class ZNPNode_ZPP_ColArbiter {
            public next: zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.dynamics.ZPP_ColArbiter;
            public elem: () => zpp_nape.dynamics.ZPP_ColArbiter;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            constructor();
        }
        export class ZNPNode_ZPP_InteractionGroup {
            public next: zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.dynamics.ZPP_InteractionGroup;
            public elem: () => zpp_nape.dynamics.ZPP_InteractionGroup;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            constructor();
        }
        export class ZNPNode_ZPP_ToiEvent {
            public next: zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_ToiEvent;
            public elem: () => zpp_nape.geom.ZPP_ToiEvent;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_ToiEvent;
            constructor();
        }
        export class ZNPNode_ConvexResult {
            public next: zpp_nape.util.ZNPNode_ConvexResult;
            public alloc: () => void;
            public free: () => void;
            public elt: nape.geom.ConvexResult;
            public elem: () => nape.geom.ConvexResult;
            public static zpp_pool: zpp_nape.util.ZNPNode_ConvexResult;
            constructor();
        }
        export class ZNPNode_ZPP_GeomPoly {
            public next: zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public alloc: () => void;
            public free: () => void;
            public elt: zpp_nape.geom.ZPP_GeomPoly;
            public elem: () => zpp_nape.geom.ZPP_GeomPoly;
            public static zpp_pool: zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            constructor();
        }
        export class ZNPNode_RayResult {
            public next: zpp_nape.util.ZNPNode_RayResult;
            public alloc: () => void;
            public free: () => void;
            public elt: nape.geom.RayResult;
            public elem: () => nape.geom.RayResult;
            public static zpp_pool: zpp_nape.util.ZNPNode_RayResult;
            constructor();
        }
        export class ZPP_MixVec2List extends nape.geom.Vec2List {
            public inner: zpp_nape.geom.ZPP_Vec2;
            public _length: number;
            public zip_length: boolean;
            public at_ite: zpp_nape.geom.ZPP_Vec2;
            public at_index: number;
            public static get(list: zpp_nape.geom.ZPP_Vec2, immutable?: boolean): zpp_nape.util.ZPP_MixVec2List;
            public zpp_gl(): number;
            public zpp_vm(): void;
            public at(index: number): nape.geom.Vec2;
            public push(obj: nape.geom.Vec2): boolean;
            public unshift(obj: nape.geom.Vec2): boolean;
            public pop(): nape.geom.Vec2;
            public shift(): nape.geom.Vec2;
            public remove(obj: nape.geom.Vec2): boolean;
            public clear(): void;
            constructor();
        }
        export class ZPP_ConstraintList {
            public outer: nape.constraint.ConstraintList;
            public inner: zpp_nape.util.ZNPList_ZPP_Constraint;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_ConstraintList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.constraint.Constraint) => boolean;
            public post_adder: (__0: nape.constraint.Constraint) => void;
            public subber: (__0: nape.constraint.Constraint) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Constraint;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Constraint;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Constraint, imm?: boolean): nape.constraint.ConstraintList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_BodyList {
            public outer: nape.phys.BodyList;
            public inner: zpp_nape.util.ZNPList_ZPP_Body;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_BodyList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.phys.Body) => boolean;
            public post_adder: (__0: nape.phys.Body) => void;
            public subber: (__0: nape.phys.Body) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Body;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Body;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Body, imm?: boolean): nape.phys.BodyList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_InteractorList {
            public outer: nape.phys.InteractorList;
            public inner: zpp_nape.util.ZNPList_ZPP_Interactor;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_InteractorList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.phys.Interactor) => boolean;
            public post_adder: (__0: nape.phys.Interactor) => void;
            public subber: (__0: nape.phys.Interactor) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Interactor;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Interactor;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Interactor, imm?: boolean): nape.phys.InteractorList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_CompoundList {
            public outer: nape.phys.CompoundList;
            public inner: zpp_nape.util.ZNPList_ZPP_Compound;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_CompoundList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.phys.Compound) => boolean;
            public post_adder: (__0: nape.phys.Compound) => void;
            public subber: (__0: nape.phys.Compound) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Compound;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Compound;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Compound, imm?: boolean): nape.phys.CompoundList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_ListenerList {
            public outer: nape.callbacks.ListenerList;
            public inner: zpp_nape.util.ZNPList_ZPP_Listener;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_ListenerList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.callbacks.Listener) => boolean;
            public post_adder: (__0: nape.callbacks.Listener) => void;
            public subber: (__0: nape.callbacks.Listener) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Listener;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Listener;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Listener, imm?: boolean): nape.callbacks.ListenerList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_CbTypeList {
            public outer: nape.callbacks.CbTypeList;
            public inner: zpp_nape.util.ZNPList_ZPP_CbType;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_CbTypeList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.callbacks.CbType) => boolean;
            public post_adder: (__0: nape.callbacks.CbType) => void;
            public subber: (__0: nape.callbacks.CbType) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_CbType;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_CbType;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_CbType, imm?: boolean): nape.callbacks.CbTypeList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_Vec2List {
            public outer: nape.geom.Vec2List;
            public inner: zpp_nape.util.ZNPList_ZPP_Vec2;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_Vec2List) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.geom.Vec2) => boolean;
            public post_adder: (__0: nape.geom.Vec2) => void;
            public subber: (__0: nape.geom.Vec2) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Vec2;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Vec2;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Vec2, imm?: boolean): nape.geom.Vec2List;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_GeomPolyList {
            public outer: nape.geom.GeomPolyList;
            public inner: zpp_nape.util.ZNPList_ZPP_GeomPoly;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_GeomPolyList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.geom.GeomPoly) => boolean;
            public post_adder: (__0: nape.geom.GeomPoly) => void;
            public subber: (__0: nape.geom.GeomPoly) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_GeomPoly;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_GeomPoly, imm?: boolean): nape.geom.GeomPolyList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_RayResultList {
            public outer: nape.geom.RayResultList;
            public inner: zpp_nape.util.ZNPList_RayResult;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_RayResultList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.geom.RayResult) => boolean;
            public post_adder: (__0: nape.geom.RayResult) => void;
            public subber: (__0: nape.geom.RayResult) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_RayResult;
            public push_ite: zpp_nape.util.ZNPNode_RayResult;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_RayResult, imm?: boolean): nape.geom.RayResultList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_ConvexResultList {
            public outer: nape.geom.ConvexResultList;
            public inner: zpp_nape.util.ZNPList_ConvexResult;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_ConvexResultList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.geom.ConvexResult) => boolean;
            public post_adder: (__0: nape.geom.ConvexResult) => void;
            public subber: (__0: nape.geom.ConvexResult) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ConvexResult;
            public push_ite: zpp_nape.util.ZNPNode_ConvexResult;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ConvexResult, imm?: boolean): nape.geom.ConvexResultList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_EdgeList {
            public outer: nape.shape.EdgeList;
            public inner: zpp_nape.util.ZNPList_ZPP_Edge;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_EdgeList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.shape.Edge) => boolean;
            public post_adder: (__0: nape.shape.Edge) => void;
            public subber: (__0: nape.shape.Edge) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Edge;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Edge;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Edge, imm?: boolean): nape.shape.EdgeList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_ShapeList {
            public outer: nape.shape.ShapeList;
            public inner: zpp_nape.util.ZNPList_ZPP_Shape;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_ShapeList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.shape.Shape) => boolean;
            public post_adder: (__0: nape.shape.Shape) => void;
            public subber: (__0: nape.shape.Shape) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Shape;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Shape;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Shape, imm?: boolean): nape.shape.ShapeList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_InteractionGroupList {
            public outer: nape.dynamics.InteractionGroupList;
            public inner: zpp_nape.util.ZNPList_ZPP_InteractionGroup;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_InteractionGroupList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.dynamics.InteractionGroup) => boolean;
            public post_adder: (__0: nape.dynamics.InteractionGroup) => void;
            public subber: (__0: nape.dynamics.InteractionGroup) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_InteractionGroup;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_InteractionGroup, imm?: boolean): nape.dynamics.InteractionGroupList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_ArbiterList {
            public outer: nape.dynamics.ArbiterList;
            public inner: zpp_nape.util.ZNPList_ZPP_Arbiter;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_ArbiterList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.dynamics.Arbiter) => boolean;
            public post_adder: (__0: nape.dynamics.Arbiter) => void;
            public subber: (__0: nape.dynamics.Arbiter) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public push_ite: zpp_nape.util.ZNPNode_ZPP_Arbiter;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.util.ZNPList_ZPP_Arbiter, imm?: boolean): nape.dynamics.ArbiterList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_ContactList {
            public outer: nape.dynamics.ContactList;
            public inner: zpp_nape.dynamics.ZPP_Contact;
            public immutable: boolean;
            public _invalidated: boolean;
            public _invalidate: (__0: zpp_nape.util.ZPP_ContactList) => void;
            public _validate: () => void;
            public _modifiable: () => void;
            public adder: (__0: nape.dynamics.Contact) => boolean;
            public post_adder: (__0: nape.dynamics.Contact) => void;
            public subber: (__0: nape.dynamics.Contact) => void;
            public dontremove: boolean;
            public reverse_flag: boolean;
            public at_index: number;
            public at_ite: zpp_nape.dynamics.ZPP_Contact;
            public push_ite: zpp_nape.dynamics.ZPP_Contact;
            public zip_length: boolean;
            public user_length: number;
            public static internal: boolean;
            public static get(list: zpp_nape.dynamics.ZPP_Contact, imm?: boolean): nape.dynamics.ContactList;
            public valmod(): void;
            public modified(): void;
            public modify_test(): void;
            public validate(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_Math {
            public static sqrt: (x: number) => number;
            public static invsqrt: (x: number) => number;
            public static sqr: (x: number) => number;
            public static clamp2: (x: number, a: number) => number;
            public static clamp: (x: number, a: number, b: number) => number;
        }
        export class ZPP_PubPool {
            public static poolGeomPoly: nape.geom.GeomPoly;
            public static nextGeomPoly: nape.geom.GeomPoly;
            public static poolVec2: nape.geom.Vec2;
            public static nextVec2: nape.geom.Vec2;
            public static poolVec3: nape.geom.Vec3;
            public static nextVec3: nape.geom.Vec3;
        }
        export class ZPP_Set_ZPP_Body {
            public free: () => void;
            public alloc: () => void;
            public lt: (__0: zpp_nape.phys.ZPP_Body, __1: zpp_nape.phys.ZPP_Body) => boolean;
            public swapped: (__0: zpp_nape.phys.ZPP_Body, __1: zpp_nape.phys.ZPP_Body) => void;
            public data: zpp_nape.phys.ZPP_Body;
            public prev: zpp_nape.util.ZPP_Set_ZPP_Body;
            public next: zpp_nape.util.ZPP_Set_ZPP_Body;
            public parent: zpp_nape.util.ZPP_Set_ZPP_Body;
            public colour: number;
            public clear_with: (lambda: (__0: zpp_nape.phys.ZPP_Body) => void) => void;
            public static zpp_pool: zpp_nape.util.ZPP_Set_ZPP_Body;
            public verify(): boolean;
            public empty(): boolean;
            public singular(): boolean;
            public size(): number;
            public has(obj: zpp_nape.phys.ZPP_Body): boolean;
            public find(obj: zpp_nape.phys.ZPP_Body): zpp_nape.util.ZPP_Set_ZPP_Body;
            public has_weak(obj: zpp_nape.phys.ZPP_Body): boolean;
            public find_weak(obj: zpp_nape.phys.ZPP_Body): zpp_nape.util.ZPP_Set_ZPP_Body;
            public lower_bound(obj: zpp_nape.phys.ZPP_Body): zpp_nape.phys.ZPP_Body;
            public first(): zpp_nape.phys.ZPP_Body;
            public pop_front(): zpp_nape.phys.ZPP_Body;
            public remove(obj: zpp_nape.phys.ZPP_Body): void;
            public successor_node(cur: zpp_nape.util.ZPP_Set_ZPP_Body): zpp_nape.util.ZPP_Set_ZPP_Body;
            public predecessor_node(cur: zpp_nape.util.ZPP_Set_ZPP_Body): zpp_nape.util.ZPP_Set_ZPP_Body;
            public successor(obj: zpp_nape.phys.ZPP_Body): zpp_nape.phys.ZPP_Body;
            public predecessor(obj: zpp_nape.phys.ZPP_Body): zpp_nape.phys.ZPP_Body;
            public remove_node(cur: zpp_nape.util.ZPP_Set_ZPP_Body): void;
            public clear(): void;
            public __fix_neg_red(negred: zpp_nape.util.ZPP_Set_ZPP_Body): void;
            public __fix_dbl_red(x: zpp_nape.util.ZPP_Set_ZPP_Body): void;
            public try_insert_bool(obj: zpp_nape.phys.ZPP_Body): boolean;
            public try_insert(obj: zpp_nape.phys.ZPP_Body): zpp_nape.util.ZPP_Set_ZPP_Body;
            public insert(obj: zpp_nape.phys.ZPP_Body): zpp_nape.util.ZPP_Set_ZPP_Body;
            constructor();
        }
        export class ZPP_Set_ZPP_CbSetPair {
            public free: () => void;
            public alloc: () => void;
            public lt: (__0: zpp_nape.callbacks.ZPP_CbSetPair, __1: zpp_nape.callbacks.ZPP_CbSetPair) => boolean;
            public swapped: (__0: zpp_nape.callbacks.ZPP_CbSetPair, __1: zpp_nape.callbacks.ZPP_CbSetPair) => void;
            public data: zpp_nape.callbacks.ZPP_CbSetPair;
            public prev: zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public next: zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public parent: zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public colour: number;
            public clear_with: (lambda: (__0: zpp_nape.callbacks.ZPP_CbSetPair) => void) => void;
            public static zpp_pool: zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public verify(): boolean;
            public empty(): boolean;
            public singular(): boolean;
            public size(): number;
            public has(obj: zpp_nape.callbacks.ZPP_CbSetPair): boolean;
            public find(obj: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public has_weak(obj: zpp_nape.callbacks.ZPP_CbSetPair): boolean;
            public find_weak(obj: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public lower_bound(obj: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.callbacks.ZPP_CbSetPair;
            public first(): zpp_nape.callbacks.ZPP_CbSetPair;
            public pop_front(): zpp_nape.callbacks.ZPP_CbSetPair;
            public remove(obj: zpp_nape.callbacks.ZPP_CbSetPair): void;
            public successor_node(cur: zpp_nape.util.ZPP_Set_ZPP_CbSetPair): zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public predecessor_node(cur: zpp_nape.util.ZPP_Set_ZPP_CbSetPair): zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public successor(obj: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.callbacks.ZPP_CbSetPair;
            public predecessor(obj: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.callbacks.ZPP_CbSetPair;
            public remove_node(cur: zpp_nape.util.ZPP_Set_ZPP_CbSetPair): void;
            public clear(): void;
            public __fix_neg_red(negred: zpp_nape.util.ZPP_Set_ZPP_CbSetPair): void;
            public __fix_dbl_red(x: zpp_nape.util.ZPP_Set_ZPP_CbSetPair): void;
            public try_insert_bool(obj: zpp_nape.callbacks.ZPP_CbSetPair): boolean;
            public try_insert(obj: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            public insert(obj: zpp_nape.callbacks.ZPP_CbSetPair): zpp_nape.util.ZPP_Set_ZPP_CbSetPair;
            constructor();
        }
        export class ZPP_Set_ZPP_PartitionVertex {
            public free: () => void;
            public alloc: () => void;
            public lt: (__0: zpp_nape.geom.ZPP_PartitionVertex, __1: zpp_nape.geom.ZPP_PartitionVertex) => boolean;
            public swapped: (__0: zpp_nape.geom.ZPP_PartitionVertex, __1: zpp_nape.geom.ZPP_PartitionVertex) => void;
            public data: zpp_nape.geom.ZPP_PartitionVertex;
            public prev: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public next: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public parent: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public colour: number;
            public clear_with: (lambda: (__0: zpp_nape.geom.ZPP_PartitionVertex) => void) => void;
            public static zpp_pool: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public verify(): boolean;
            public empty(): boolean;
            public singular(): boolean;
            public size(): number;
            public has(obj: zpp_nape.geom.ZPP_PartitionVertex): boolean;
            public find(obj: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public has_weak(obj: zpp_nape.geom.ZPP_PartitionVertex): boolean;
            public find_weak(obj: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public lower_bound(obj: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.geom.ZPP_PartitionVertex;
            public first(): zpp_nape.geom.ZPP_PartitionVertex;
            public pop_front(): zpp_nape.geom.ZPP_PartitionVertex;
            public remove(obj: zpp_nape.geom.ZPP_PartitionVertex): void;
            public successor_node(cur: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex): zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public predecessor_node(cur: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex): zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public successor(obj: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.geom.ZPP_PartitionVertex;
            public predecessor(obj: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.geom.ZPP_PartitionVertex;
            public remove_node(cur: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex): void;
            public clear(): void;
            public __fix_neg_red(negred: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex): void;
            public __fix_dbl_red(x: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex): void;
            public try_insert_bool(obj: zpp_nape.geom.ZPP_PartitionVertex): boolean;
            public try_insert(obj: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public insert(obj: zpp_nape.geom.ZPP_PartitionVertex): zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            constructor();
        }
        export class ZPP_Set_ZPP_PartitionPair {
            public free: () => void;
            public alloc: () => void;
            public lt: (__0: zpp_nape.geom.ZPP_PartitionPair, __1: zpp_nape.geom.ZPP_PartitionPair) => boolean;
            public swapped: (__0: zpp_nape.geom.ZPP_PartitionPair, __1: zpp_nape.geom.ZPP_PartitionPair) => void;
            public data: zpp_nape.geom.ZPP_PartitionPair;
            public prev: zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public next: zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public parent: zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public colour: number;
            public clear_with: (lambda: (__0: zpp_nape.geom.ZPP_PartitionPair) => void) => void;
            public static zpp_pool: zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public verify(): boolean;
            public empty(): boolean;
            public singular(): boolean;
            public size(): number;
            public has(obj: zpp_nape.geom.ZPP_PartitionPair): boolean;
            public find(obj: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public has_weak(obj: zpp_nape.geom.ZPP_PartitionPair): boolean;
            public find_weak(obj: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public lower_bound(obj: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.geom.ZPP_PartitionPair;
            public first(): zpp_nape.geom.ZPP_PartitionPair;
            public pop_front(): zpp_nape.geom.ZPP_PartitionPair;
            public remove(obj: zpp_nape.geom.ZPP_PartitionPair): void;
            public successor_node(cur: zpp_nape.util.ZPP_Set_ZPP_PartitionPair): zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public predecessor_node(cur: zpp_nape.util.ZPP_Set_ZPP_PartitionPair): zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public successor(obj: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.geom.ZPP_PartitionPair;
            public predecessor(obj: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.geom.ZPP_PartitionPair;
            public remove_node(cur: zpp_nape.util.ZPP_Set_ZPP_PartitionPair): void;
            public clear(): void;
            public __fix_neg_red(negred: zpp_nape.util.ZPP_Set_ZPP_PartitionPair): void;
            public __fix_dbl_red(x: zpp_nape.util.ZPP_Set_ZPP_PartitionPair): void;
            public try_insert_bool(obj: zpp_nape.geom.ZPP_PartitionPair): boolean;
            public try_insert(obj: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public insert(obj: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            constructor();
        }
        export class ZPP_Set_ZPP_SimpleVert {
            public free: () => void;
            public alloc: () => void;
            public lt: (__0: zpp_nape.geom.ZPP_SimpleVert, __1: zpp_nape.geom.ZPP_SimpleVert) => boolean;
            public swapped: (__0: zpp_nape.geom.ZPP_SimpleVert, __1: zpp_nape.geom.ZPP_SimpleVert) => void;
            public data: zpp_nape.geom.ZPP_SimpleVert;
            public prev: zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public next: zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public parent: zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public colour: number;
            public clear_with: (lambda: (__0: zpp_nape.geom.ZPP_SimpleVert) => void) => void;
            public static zpp_pool: zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public verify(): boolean;
            public empty(): boolean;
            public singular(): boolean;
            public size(): number;
            public has(obj: zpp_nape.geom.ZPP_SimpleVert): boolean;
            public find(obj: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public has_weak(obj: zpp_nape.geom.ZPP_SimpleVert): boolean;
            public find_weak(obj: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public lower_bound(obj: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.geom.ZPP_SimpleVert;
            public first(): zpp_nape.geom.ZPP_SimpleVert;
            public pop_front(): zpp_nape.geom.ZPP_SimpleVert;
            public remove(obj: zpp_nape.geom.ZPP_SimpleVert): void;
            public successor_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleVert): zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public predecessor_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleVert): zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public successor(obj: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.geom.ZPP_SimpleVert;
            public predecessor(obj: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.geom.ZPP_SimpleVert;
            public remove_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleVert): void;
            public clear(): void;
            public __fix_neg_red(negred: zpp_nape.util.ZPP_Set_ZPP_SimpleVert): void;
            public __fix_dbl_red(x: zpp_nape.util.ZPP_Set_ZPP_SimpleVert): void;
            public try_insert_bool(obj: zpp_nape.geom.ZPP_SimpleVert): boolean;
            public try_insert(obj: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public insert(obj: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            constructor();
        }
        export class ZPP_Set_ZPP_SimpleSeg {
            public free: () => void;
            public alloc: () => void;
            public lt: (__0: zpp_nape.geom.ZPP_SimpleSeg, __1: zpp_nape.geom.ZPP_SimpleSeg) => boolean;
            public swapped: (__0: zpp_nape.geom.ZPP_SimpleSeg, __1: zpp_nape.geom.ZPP_SimpleSeg) => void;
            public data: zpp_nape.geom.ZPP_SimpleSeg;
            public prev: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public next: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public parent: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public colour: number;
            public clear_with: (lambda: (__0: zpp_nape.geom.ZPP_SimpleSeg) => void) => void;
            public static zpp_pool: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public verify(): boolean;
            public empty(): boolean;
            public singular(): boolean;
            public size(): number;
            public has(obj: zpp_nape.geom.ZPP_SimpleSeg): boolean;
            public find(obj: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public has_weak(obj: zpp_nape.geom.ZPP_SimpleSeg): boolean;
            public find_weak(obj: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public lower_bound(obj: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.geom.ZPP_SimpleSeg;
            public first(): zpp_nape.geom.ZPP_SimpleSeg;
            public pop_front(): zpp_nape.geom.ZPP_SimpleSeg;
            public remove(obj: zpp_nape.geom.ZPP_SimpleSeg): void;
            public successor_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg): zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public predecessor_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg): zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public successor(obj: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.geom.ZPP_SimpleSeg;
            public predecessor(obj: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.geom.ZPP_SimpleSeg;
            public remove_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg): void;
            public clear(): void;
            public __fix_neg_red(negred: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg): void;
            public __fix_dbl_red(x: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg): void;
            public try_insert_bool(obj: zpp_nape.geom.ZPP_SimpleSeg): boolean;
            public try_insert(obj: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public insert(obj: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            constructor();
        }
        export class ZPP_Set_ZPP_SimpleEvent {
            public free: () => void;
            public alloc: () => void;
            public lt: (__0: zpp_nape.geom.ZPP_SimpleEvent, __1: zpp_nape.geom.ZPP_SimpleEvent) => boolean;
            public swapped: (__0: zpp_nape.geom.ZPP_SimpleEvent, __1: zpp_nape.geom.ZPP_SimpleEvent) => void;
            public data: zpp_nape.geom.ZPP_SimpleEvent;
            public prev: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public next: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public parent: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public colour: number;
            public clear_with: (lambda: (__0: zpp_nape.geom.ZPP_SimpleEvent) => void) => void;
            public static zpp_pool: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public verify(): boolean;
            public empty(): boolean;
            public singular(): boolean;
            public size(): number;
            public has(obj: zpp_nape.geom.ZPP_SimpleEvent): boolean;
            public find(obj: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public has_weak(obj: zpp_nape.geom.ZPP_SimpleEvent): boolean;
            public find_weak(obj: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public lower_bound(obj: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.geom.ZPP_SimpleEvent;
            public first(): zpp_nape.geom.ZPP_SimpleEvent;
            public pop_front(): zpp_nape.geom.ZPP_SimpleEvent;
            public remove(obj: zpp_nape.geom.ZPP_SimpleEvent): void;
            public successor_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent): zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public predecessor_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent): zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public successor(obj: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.geom.ZPP_SimpleEvent;
            public predecessor(obj: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.geom.ZPP_SimpleEvent;
            public remove_node(cur: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent): void;
            public clear(): void;
            public __fix_neg_red(negred: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent): void;
            public __fix_dbl_red(x: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent): void;
            public try_insert_bool(obj: zpp_nape.geom.ZPP_SimpleEvent): boolean;
            public try_insert(obj: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public insert(obj: zpp_nape.geom.ZPP_SimpleEvent): zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            constructor();
        }
        export class ZPP_Set_ZPP_CbSet {
            public free: () => void;
            public alloc: () => void;
            public lt: (__0: zpp_nape.callbacks.ZPP_CbSet, __1: zpp_nape.callbacks.ZPP_CbSet) => boolean;
            public swapped: (__0: zpp_nape.callbacks.ZPP_CbSet, __1: zpp_nape.callbacks.ZPP_CbSet) => void;
            public data: zpp_nape.callbacks.ZPP_CbSet;
            public prev: zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public next: zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public parent: zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public colour: number;
            public clear_with: (lambda: (__0: zpp_nape.callbacks.ZPP_CbSet) => void) => void;
            public static zpp_pool: zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public verify(): boolean;
            public empty(): boolean;
            public singular(): boolean;
            public size(): number;
            public has(obj: zpp_nape.callbacks.ZPP_CbSet): boolean;
            public find(obj: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public has_weak(obj: zpp_nape.callbacks.ZPP_CbSet): boolean;
            public find_weak(obj: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public lower_bound(obj: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.callbacks.ZPP_CbSet;
            public first(): zpp_nape.callbacks.ZPP_CbSet;
            public pop_front(): zpp_nape.callbacks.ZPP_CbSet;
            public remove(obj: zpp_nape.callbacks.ZPP_CbSet): void;
            public successor_node(cur: zpp_nape.util.ZPP_Set_ZPP_CbSet): zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public predecessor_node(cur: zpp_nape.util.ZPP_Set_ZPP_CbSet): zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public successor(obj: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.callbacks.ZPP_CbSet;
            public predecessor(obj: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.callbacks.ZPP_CbSet;
            public remove_node(cur: zpp_nape.util.ZPP_Set_ZPP_CbSet): void;
            public clear(): void;
            public __fix_neg_red(negred: zpp_nape.util.ZPP_Set_ZPP_CbSet): void;
            public __fix_dbl_red(x: zpp_nape.util.ZPP_Set_ZPP_CbSet): void;
            public try_insert_bool(obj: zpp_nape.callbacks.ZPP_CbSet): boolean;
            public try_insert(obj: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public insert(obj: zpp_nape.callbacks.ZPP_CbSet): zpp_nape.util.ZPP_Set_ZPP_CbSet;
            constructor();
        }
    }
    export module constraint {
        export class ZPP_Constraint {
            public outer: nape.constraint.Constraint;
            public id: number;
            public userData: any;
            public compound: zpp_nape.phys.ZPP_Compound;
            public space: zpp_nape.space.ZPP_Space;
            public active: boolean;
            public stiff: boolean;
            public frequency: number;
            public damping: number;
            public maxForce: number;
            public maxError: number;
            public breakUnderForce: boolean;
            public breakUnderError: boolean;
            public removeOnBreak: boolean;
            public component: zpp_nape.space.ZPP_Component;
            public ignore: boolean;
            public __velocity: boolean;
            public cbTypes: zpp_nape.util.ZNPList_ZPP_CbType;
            public cbSet: zpp_nape.callbacks.ZPP_CbSet;
            public wrap_cbTypes: nape.callbacks.CbTypeList;
            public pre_dt: number;
            public clear(): void;
            public immutable_midstep(name: String): void;
            public setupcbTypes(): void;
            public insert_cbtype(cb: zpp_nape.callbacks.ZPP_CbType): void;
            public alloc_cbSet(): void;
            public dealloc_cbSet(): void;
            public activate(): void;
            public deactivate(): void;
            public addedToSpace(): void;
            public removedFromSpace(): void;
            public activeInSpace(): void;
            public inactiveOrOutSpace(): void;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public clearcache(): void;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public broken(): void;
            public warmStart(): void;
            public preStep(dt: number): boolean;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            public wake(): void;
            public draw(g: nape.util.Debug): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public copyto(ret: nape.constraint.Constraint): void;
            constructor();
        }
        export class ZPP_AngleJoint extends zpp_nape.constraint.ZPP_Constraint {
            public outer_zn: nape.constraint.AngleJoint;
            public ratio: number;
            public jointMin: number;
            public jointMax: number;
            public slack: boolean;
            public equal: boolean;
            public scale: number;
            public is_slack: () => boolean;
            public b1: zpp_nape.phys.ZPP_Body;
            public b2: zpp_nape.phys.ZPP_Body;
            public kMass: number;
            public jAcc: number;
            public jMax: number;
            public gamma: number;
            public bias: number;
            public stepped: boolean;
            public bodyImpulse(b: zpp_nape.phys.ZPP_Body): nape.geom.Vec3;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public clearcache(): void;
            public preStep(dt: number): boolean;
            public warmStart(): void;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            public draw(g: nape.util.Debug): void;
            constructor();
        }
        export class ZPP_CopyHelper {
            public id: number;
            public bc: nape.phys.Body;
            public cb: (__0: nape.phys.Body) => void;
            public static dict(id: number, bc: nape.phys.Body): zpp_nape.constraint.ZPP_CopyHelper;
            public static todo(id: number, cb: (__0: nape.phys.Body) => void): zpp_nape.constraint.ZPP_CopyHelper;
        }
        export class ZPP_DistanceJoint extends zpp_nape.constraint.ZPP_Constraint {
            public outer_zn: nape.constraint.DistanceJoint;
            public jointMin: number;
            public jointMax: number;
            public slack: boolean;
            public equal: boolean;
            public is_slack: () => boolean;
            public nx: number;
            public ny: number;
            public cx1: number;
            public cx2: number;
            public b1: zpp_nape.phys.ZPP_Body;
            public a1localx: number;
            public a1localy: number;
            public a1relx: number;
            public a1rely: number;
            public wrap_a1: nape.geom.Vec2;
            public b2: zpp_nape.phys.ZPP_Body;
            public a2localx: number;
            public a2localy: number;
            public a2relx: number;
            public a2rely: number;
            public wrap_a2: nape.geom.Vec2;
            public kMass: number;
            public jAcc: number;
            public jMax: number;
            public gamma: number;
            public bias: number;
            public stepped: boolean;
            public bodyImpulse(b: zpp_nape.phys.ZPP_Body): nape.geom.Vec3;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public setup_a1(): void;
            public setup_a2(): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public clearcache(): void;
            public preStep(dt: number): boolean;
            public warmStart(): void;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            public draw(g: nape.util.Debug): void;
            constructor();
        }
        export class ZPP_LineJoint extends zpp_nape.constraint.ZPP_Constraint {
            public outer_zn: nape.constraint.LineJoint;
            public scale: number;
            public jointMin: number;
            public jointMax: number;
            public equal: boolean;
            public dot1: number;
            public dot2: number;
            public cx1: number;
            public cx2: number;
            public b1: zpp_nape.phys.ZPP_Body;
            public a1localx: number;
            public a1localy: number;
            public a1relx: number;
            public a1rely: number;
            public wrap_a1: nape.geom.Vec2;
            public b2: zpp_nape.phys.ZPP_Body;
            public a2localx: number;
            public a2localy: number;
            public a2relx: number;
            public a2rely: number;
            public wrap_a2: nape.geom.Vec2;
            public zip_n: boolean;
            public nlocalx: number;
            public nlocaly: number;
            public nrelx: number;
            public nrely: number;
            public wrap_n: nape.geom.Vec2;
            public kMassa: number;
            public kMassb: number;
            public kMassc: number;
            public jAccx: number;
            public jAccy: number;
            public jMax: number;
            public gamma: number;
            public biasx: number;
            public biasy: number;
            public stepped: boolean;
            public bodyImpulse(b: zpp_nape.phys.ZPP_Body): nape.geom.Vec3;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public setup_a1(): void;
            public setup_a2(): void;
            public setup_n(): void;
            public validate_norm(): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public clearcache(): void;
            public preStep(dt: number): boolean;
            public warmStart(): void;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            public draw(g: nape.util.Debug): void;
            constructor();
        }
        export class ZPP_MotorJoint extends zpp_nape.constraint.ZPP_Constraint {
            public outer_zn: nape.constraint.MotorJoint;
            public ratio: number;
            public rate: number;
            public b1: zpp_nape.phys.ZPP_Body;
            public b2: zpp_nape.phys.ZPP_Body;
            public kMass: number;
            public jAcc: number;
            public jMax: number;
            public stepped: boolean;
            public bodyImpulse(b: zpp_nape.phys.ZPP_Body): nape.geom.Vec3;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public clearcache(): void;
            public preStep(dt: number): boolean;
            public warmStart(): void;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            constructor();
        }
        export class ZPP_PivotJoint extends zpp_nape.constraint.ZPP_Constraint {
            public outer_zn: nape.constraint.PivotJoint;
            public b1: zpp_nape.phys.ZPP_Body;
            public a1localx: number;
            public a1localy: number;
            public a1relx: number;
            public a1rely: number;
            public wrap_a1: nape.geom.Vec2;
            public b2: zpp_nape.phys.ZPP_Body;
            public a2localx: number;
            public a2localy: number;
            public a2relx: number;
            public a2rely: number;
            public wrap_a2: nape.geom.Vec2;
            public kMassa: number;
            public kMassb: number;
            public kMassc: number;
            public jAccx: number;
            public jAccy: number;
            public jMax: number;
            public gamma: number;
            public biasx: number;
            public biasy: number;
            public stepped: boolean;
            public bodyImpulse(b: zpp_nape.phys.ZPP_Body): nape.geom.Vec3;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public setup_a1(): void;
            public setup_a2(): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public clearcache(): void;
            public preStep(dt: number): boolean;
            public warmStart(): void;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            public draw(g: nape.util.Debug): void;
            constructor();
        }
        export class ZPP_PulleyJoint extends zpp_nape.constraint.ZPP_Constraint {
            public outer_zn: nape.constraint.PulleyJoint;
            public ratio: number;
            public jointMin: number;
            public jointMax: number;
            public slack: boolean;
            public equal: boolean;
            public is_slack: () => boolean;
            public n12x: number;
            public n12y: number;
            public n34x: number;
            public n34y: number;
            public cx1: number;
            public cx2: number;
            public cx3: number;
            public cx4: number;
            public b1: zpp_nape.phys.ZPP_Body;
            public a1localx: number;
            public a1localy: number;
            public a1relx: number;
            public a1rely: number;
            public wrap_a1: nape.geom.Vec2;
            public b2: zpp_nape.phys.ZPP_Body;
            public a2localx: number;
            public a2localy: number;
            public a2relx: number;
            public a2rely: number;
            public wrap_a2: nape.geom.Vec2;
            public b3: zpp_nape.phys.ZPP_Body;
            public a3localx: number;
            public a3localy: number;
            public a3relx: number;
            public a3rely: number;
            public wrap_a3: nape.geom.Vec2;
            public b4: zpp_nape.phys.ZPP_Body;
            public a4localx: number;
            public a4localy: number;
            public a4relx: number;
            public a4rely: number;
            public wrap_a4: nape.geom.Vec2;
            public kMass: number;
            public jAcc: number;
            public jMax: number;
            public gamma: number;
            public bias: number;
            public stepped: boolean;
            public bodyImpulse(b: zpp_nape.phys.ZPP_Body): nape.geom.Vec3;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public setup_a1(): void;
            public setup_a2(): void;
            public setup_a3(): void;
            public setup_a4(): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public clearcache(): void;
            public preStep(dt: number): boolean;
            public warmStart(): void;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            public draw(g: nape.util.Debug): void;
            constructor();
        }
        export class ZPP_UserConstraint extends zpp_nape.constraint.ZPP_Constraint {
            public outer_zn: nape.constraint.UserConstraint;
            public bodies: zpp_nape.constraint.ZPP_UserBody[];
            public dim: number;
            public jAcc: number[];
            public bias: number[];
            public stepped: boolean;
            public soft: number;
            public gamma: number;
            public velonly: boolean;
            public jMax: number;
            public Keff: number[];
            public bindVec2_invalidate(_: zpp_nape.geom.ZPP_Vec2): void;
            public addBody(b: zpp_nape.phys.ZPP_Body): void;
            public remBody(b: zpp_nape.phys.ZPP_Body): boolean;
            public bodyImpulse(b: zpp_nape.phys.ZPP_Body): nape.geom.Vec3;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public broken(): void;
            public clearcache(): void;
            public lsq(v: number[]): number;
            public _clamp(v: number[], max: number): void;
            public solve(m: number[]): number[];
            public transform(L: number[], x: number[]): void;
            public preStep(dt: number): boolean;
            public warmStart(): void;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            public draw(g: nape.util.Debug): void;
            constructor(dim: number, velonly: boolean);
        }
        export class ZPP_UserBody {
            public cnt: number;
            public body: zpp_nape.phys.ZPP_Body;
            constructor(cnt: number, body: zpp_nape.phys.ZPP_Body);
        }
        export class ZPP_WeldJoint extends zpp_nape.constraint.ZPP_Constraint {
            public outer_zn: nape.constraint.WeldJoint;
            public b1: zpp_nape.phys.ZPP_Body;
            public a1localx: number;
            public a1localy: number;
            public a1relx: number;
            public a1rely: number;
            public wrap_a1: nape.geom.Vec2;
            public b2: zpp_nape.phys.ZPP_Body;
            public a2localx: number;
            public a2localy: number;
            public a2relx: number;
            public a2rely: number;
            public wrap_a2: nape.geom.Vec2;
            public phase: number;
            public kMassa: number;
            public kMassb: number;
            public kMassd: number;
            public kMassc: number;
            public kMasse: number;
            public kMassf: number;
            public jAccx: number;
            public jAccy: number;
            public jAccz: number;
            public jMax: number;
            public gamma: number;
            public biasx: number;
            public biasy: number;
            public biasz: number;
            public stepped: boolean;
            public bodyImpulse(b: zpp_nape.phys.ZPP_Body): nape.geom.Vec3;
            public activeBodies(): void;
            public inactiveBodies(): void;
            public setup_a1(): void;
            public setup_a2(): void;
            public copy(dict?: any[], todo?: any[]): nape.constraint.Constraint;
            public validate(): void;
            public wake_connected(): void;
            public forest(): void;
            public pair_exists(id: number, di: number): boolean;
            public clearcache(): void;
            public preStep(dt: number): boolean;
            public warmStart(): void;
            public applyImpulseVel(): boolean;
            public applyImpulsePos(): boolean;
            public draw(g: nape.util.Debug): void;
            constructor();
        }
    }
    export module dynamics {
        export class ZPP_Arbiter {
            public outer: nape.dynamics.Arbiter;
            public inactiveme: () => boolean;
            public hnext: zpp_nape.dynamics.ZPP_Arbiter;
            public id: number;
            public di: number;
            public stamp: number;
            public up_stamp: number;
            public sleep_stamp: number;
            public endGenerated: number;
            public active: boolean;
            public cleared: boolean;
            public sleeping: boolean;
            public present: number;
            public intchange: boolean;
            public presentable: boolean;
            public continuous: boolean;
            public fresh: boolean;
            public immState: number;
            public acting: () => boolean;
            public invalidated: boolean;
            public b1: zpp_nape.phys.ZPP_Body;
            public b2: zpp_nape.phys.ZPP_Body;
            public ws1: zpp_nape.shape.ZPP_Shape;
            public ws2: zpp_nape.shape.ZPP_Shape;
            public pair: zpp_nape.space.ZPP_AABBPair;
            public swap_features: () => void;
            public type: number;
            public colarb: zpp_nape.dynamics.ZPP_ColArbiter;
            public fluidarb: zpp_nape.dynamics.ZPP_FluidArbiter;
            public sensorarb: zpp_nape.dynamics.ZPP_SensorArbiter;
            public lazyRetire: (s: zpp_nape.space.ZPP_Space, b?: zpp_nape.phys.ZPP_Body) => void;
            public sup_assign: (s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, id: number, di: number) => void;
            public sup_retire: () => void;
            public static internal: boolean;
            public static COL: number;
            public static FLUID: number;
            public static SENSOR: number;
            public static types: any[];
            public wrapper(): nape.dynamics.Arbiter;
            constructor();
        }
        export class ZPP_SensorArbiter extends zpp_nape.dynamics.ZPP_Arbiter {
            public next: zpp_nape.dynamics.ZPP_SensorArbiter;
            public alloc: () => void;
            public free: () => void;
            public assign: (s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, id: number, di: number) => void;
            public retire: () => void;
            public makemutable: () => void;
            public makeimmutable: () => void;
            public static zpp_pool: zpp_nape.dynamics.ZPP_SensorArbiter;
            constructor();
        }
        export class ZPP_FluidArbiter extends zpp_nape.dynamics.ZPP_Arbiter {
            public outer_zn: nape.dynamics.FluidArbiter;
            public next: zpp_nape.dynamics.ZPP_FluidArbiter;
            public alloc: () => void;
            public free: () => void;
            public centroidx: number;
            public centroidy: number;
            public overlap: number;
            public r1x: number;
            public r1y: number;
            public r2x: number;
            public r2y: number;
            public nodrag: boolean;
            public wMass: number;
            public adamp: number;
            public agamma: number;
            public vMassa: number;
            public vMassb: number;
            public vMassc: number;
            public dampx: number;
            public dampy: number;
            public lgamma: number;
            public nx: number;
            public ny: number;
            public buoyx: number;
            public buoyy: number;
            public wrap_position: nape.geom.Vec2;
            public assign: (s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, id: number, di: number) => void;
            public retire: () => void;
            public mutable: boolean;
            public makemutable: () => void;
            public makeimmutable: () => void;
            public inject: (area: number, cx: number, cy: number) => void;
            public pre_dt: number;
            public preStep: (s: zpp_nape.space.ZPP_Space, dt: number) => void;
            public warmStart: () => void;
            public applyImpulseVel: () => void;
            public static zpp_pool: zpp_nape.dynamics.ZPP_FluidArbiter;
            public getposition(): void;
            constructor();
        }
        export class ZPP_ColArbiter extends zpp_nape.dynamics.ZPP_Arbiter {
            public outer_zn: nape.dynamics.CollisionArbiter;
            public dyn_fric: number;
            public stat_fric: number;
            public restitution: number;
            public rfric: number;
            public userdef_dyn_fric: boolean;
            public userdef_stat_fric: boolean;
            public userdef_restitution: boolean;
            public userdef_rfric: boolean;
            public s1: zpp_nape.shape.ZPP_Shape;
            public s2: zpp_nape.shape.ZPP_Shape;
            public contacts: zpp_nape.dynamics.ZPP_Contact;
            public wrap_contacts: nape.dynamics.ContactList;
            public innards: zpp_nape.dynamics.ZPP_IContact;
            public nx: number;
            public ny: number;
            public wrap_normal: nape.geom.Vec2;
            public rMass: number;
            public jrAcc: number;
            public surfacex: number;
            public surfacey: number;
            public ptype: number;
            public lnormx: number;
            public lnormy: number;
            public lproj: number;
            public radius: number;
            public rev: boolean;
            public __ref_edge1: zpp_nape.shape.ZPP_Edge;
            public __ref_edge2: zpp_nape.shape.ZPP_Edge;
            public __ref_vertex: number;
            public c1: zpp_nape.dynamics.ZPP_IContact;
            public oc1: zpp_nape.dynamics.ZPP_Contact;
            public c2: zpp_nape.dynamics.ZPP_IContact;
            public oc2: zpp_nape.dynamics.ZPP_Contact;
            public hc2: boolean;
            public hpc2: boolean;
            public next: zpp_nape.dynamics.ZPP_ColArbiter;
            public alloc: () => void;
            public free: () => void;
            public stat: boolean;
            public injectContact: (px: number, py: number, nx: number, ny: number, dist: number, hash: number, posOnly?: boolean) => zpp_nape.dynamics.ZPP_Contact;
            public assign: (s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, id: number, di: number) => void;
            public calcProperties: () => void;
            public validate_props: () => void;
            public retire: () => void;
            public mutable: boolean;
            public makemutable: () => void;
            public makeimmutable: () => void;
            public cleanupContacts: () => boolean;
            public pre_dt: number;
            public preStep: (dt: number) => boolean;
            public warmStart: () => void;
            public applyImpulseVel: () => void;
            public applyImpulsePos: () => void;
            public static FACE1: number;
            public static FACE2: number;
            public static CIRCLE: number;
            public static zpp_pool: zpp_nape.dynamics.ZPP_ColArbiter;
            public getnormal(): void;
            public setupcontacts(): void;
            constructor();
        }
        export class ZPP_Contact {
            public outer: nape.dynamics.Contact;
            public px: number;
            public py: number;
            public wrap_position: nape.geom.Vec2;
            public arbiter: zpp_nape.dynamics.ZPP_Arbiter;
            public inner: zpp_nape.dynamics.ZPP_IContact;
            public active: boolean;
            public posOnly: boolean;
            public stamp: number;
            public hash: number;
            public fresh: boolean;
            public dist: number;
            public elasticity: number;
            public free: () => void;
            public alloc: () => void;
            public next: zpp_nape.dynamics.ZPP_Contact;
            public elem: () => zpp_nape.dynamics.ZPP_Contact;
            public begin: () => zpp_nape.dynamics.ZPP_Contact;
            public _inuse: boolean;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.dynamics.ZPP_Contact) => void;
            public inlined_add: (o: zpp_nape.dynamics.ZPP_Contact) => zpp_nape.dynamics.ZPP_Contact;
            public inlined_insert: (cur: zpp_nape.dynamics.ZPP_Contact, o: zpp_nape.dynamics.ZPP_Contact) => zpp_nape.dynamics.ZPP_Contact;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.dynamics.ZPP_Contact;
            public inlined_remove: (obj: zpp_nape.dynamics.ZPP_Contact) => void;
            public inlined_try_remove: (obj: zpp_nape.dynamics.ZPP_Contact) => boolean;
            public inlined_erase: (pre: zpp_nape.dynamics.ZPP_Contact) => zpp_nape.dynamics.ZPP_Contact;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.dynamics.ZPP_Contact) => boolean;
            public front: () => zpp_nape.dynamics.ZPP_Contact;
            public static internal: boolean;
            public static zpp_pool: zpp_nape.dynamics.ZPP_Contact;
            public wrapper(): nape.dynamics.Contact;
            public getposition(): void;
            public inactiveme(): boolean;
            public add(o: zpp_nape.dynamics.ZPP_Contact): zpp_nape.dynamics.ZPP_Contact;
            public addAll(x: zpp_nape.dynamics.ZPP_Contact): void;
            public insert(cur: zpp_nape.dynamics.ZPP_Contact, o: zpp_nape.dynamics.ZPP_Contact): zpp_nape.dynamics.ZPP_Contact;
            public pop(): void;
            public pop_unsafe(): zpp_nape.dynamics.ZPP_Contact;
            public remove(obj: zpp_nape.dynamics.ZPP_Contact): void;
            public try_remove(obj: zpp_nape.dynamics.ZPP_Contact): boolean;
            public erase(pre: zpp_nape.dynamics.ZPP_Contact): zpp_nape.dynamics.ZPP_Contact;
            public splice(pre: zpp_nape.dynamics.ZPP_Contact, n: number): zpp_nape.dynamics.ZPP_Contact;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.dynamics.ZPP_Contact): boolean;
            public back(): zpp_nape.dynamics.ZPP_Contact;
            public iterator_at(ind: number): zpp_nape.dynamics.ZPP_Contact;
            public at(ind: number): zpp_nape.dynamics.ZPP_Contact;
            constructor();
        }
        export class ZPP_IContact {
            public r1x: number;
            public r1y: number;
            public r2x: number;
            public r2y: number;
            public nMass: number;
            public tMass: number;
            public bounce: number;
            public friction: number;
            public jnAcc: number;
            public jtAcc: number;
            public lr1x: number;
            public lr1y: number;
            public lr2x: number;
            public lr2y: number;
            public next: zpp_nape.dynamics.ZPP_IContact;
            public elem: () => zpp_nape.dynamics.ZPP_IContact;
            public begin: () => zpp_nape.dynamics.ZPP_IContact;
            public _inuse: boolean;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.dynamics.ZPP_IContact) => void;
            public inlined_add: (o: zpp_nape.dynamics.ZPP_IContact) => zpp_nape.dynamics.ZPP_IContact;
            public inlined_insert: (cur: zpp_nape.dynamics.ZPP_IContact, o: zpp_nape.dynamics.ZPP_IContact) => zpp_nape.dynamics.ZPP_IContact;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.dynamics.ZPP_IContact;
            public inlined_remove: (obj: zpp_nape.dynamics.ZPP_IContact) => void;
            public inlined_try_remove: (obj: zpp_nape.dynamics.ZPP_IContact) => boolean;
            public inlined_erase: (pre: zpp_nape.dynamics.ZPP_IContact) => zpp_nape.dynamics.ZPP_IContact;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.dynamics.ZPP_IContact) => boolean;
            public front: () => zpp_nape.dynamics.ZPP_IContact;
            public add(o: zpp_nape.dynamics.ZPP_IContact): zpp_nape.dynamics.ZPP_IContact;
            public addAll(x: zpp_nape.dynamics.ZPP_IContact): void;
            public insert(cur: zpp_nape.dynamics.ZPP_IContact, o: zpp_nape.dynamics.ZPP_IContact): zpp_nape.dynamics.ZPP_IContact;
            public pop(): void;
            public pop_unsafe(): zpp_nape.dynamics.ZPP_IContact;
            public remove(obj: zpp_nape.dynamics.ZPP_IContact): void;
            public try_remove(obj: zpp_nape.dynamics.ZPP_IContact): boolean;
            public erase(pre: zpp_nape.dynamics.ZPP_IContact): zpp_nape.dynamics.ZPP_IContact;
            public splice(pre: zpp_nape.dynamics.ZPP_IContact, n: number): zpp_nape.dynamics.ZPP_IContact;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.dynamics.ZPP_IContact): boolean;
            public back(): zpp_nape.dynamics.ZPP_IContact;
            public iterator_at(ind: number): zpp_nape.dynamics.ZPP_IContact;
            public at(ind: number): zpp_nape.dynamics.ZPP_IContact;
            constructor();
        }
        export class ZPP_InteractionFilter {
            public next: zpp_nape.dynamics.ZPP_InteractionFilter;
            public userData: any;
            public outer: nape.dynamics.InteractionFilter;
            public free: () => void;
            public alloc: () => void;
            public shapes: zpp_nape.util.ZNPList_ZPP_Shape;
            public wrap_shapes: nape.shape.ShapeList;
            public feature_cons: () => void;
            public addShape: (shape: zpp_nape.shape.ZPP_Shape) => void;
            public remShape: (shape: zpp_nape.shape.ZPP_Shape) => void;
            public collisionGroup: number;
            public collisionMask: number;
            public shouldCollide: (x: zpp_nape.dynamics.ZPP_InteractionFilter) => boolean;
            public sensorGroup: number;
            public sensorMask: number;
            public shouldSense: (x: zpp_nape.dynamics.ZPP_InteractionFilter) => boolean;
            public fluidGroup: number;
            public fluidMask: number;
            public shouldFlow: (x: zpp_nape.dynamics.ZPP_InteractionFilter) => boolean;
            public static zpp_pool: zpp_nape.dynamics.ZPP_InteractionFilter;
            public wrapper(): nape.dynamics.InteractionFilter;
            public copy(): zpp_nape.dynamics.ZPP_InteractionFilter;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_InteractionGroup {
            public outer: nape.dynamics.InteractionGroup;
            public ignore: boolean;
            public group: zpp_nape.dynamics.ZPP_InteractionGroup;
            public groups: zpp_nape.util.ZNPList_ZPP_InteractionGroup;
            public wrap_groups: nape.dynamics.InteractionGroupList;
            public interactors: zpp_nape.util.ZNPList_ZPP_Interactor;
            public wrap_interactors: nape.phys.InteractorList;
            public depth: number;
            public addGroup: (group: zpp_nape.dynamics.ZPP_InteractionGroup) => void;
            public remGroup: (group: zpp_nape.dynamics.ZPP_InteractionGroup) => void;
            public addInteractor: (intx: zpp_nape.phys.ZPP_Interactor) => void;
            public remInteractor: (intx: zpp_nape.phys.ZPP_Interactor, flag?: number) => void;
            public static SHAPE: number;
            public static BODY: number;
            public setGroup(group: zpp_nape.dynamics.ZPP_InteractionGroup): void;
            public invalidate(force?: boolean): void;
            constructor();
        }
        export class ZPP_SpaceArbiterList extends nape.dynamics.ArbiterList {
            public space: zpp_nape.space.ZPP_Space;
            public _length: number;
            public zip_length: boolean;
            public lengths: any[];
            public ite_0: zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public ite_1: zpp_nape.util.ZNPNode_ZPP_ColArbiter;
            public ite_2: zpp_nape.util.ZNPNode_ZPP_FluidArbiter;
            public ite_3: zpp_nape.util.ZNPNode_ZPP_SensorArbiter;
            public at_index_0: number;
            public at_index_1: number;
            public at_index_2: number;
            public at_index_3: number;
            public zpp_gl(): number;
            public zpp_vm(): void;
            public push(obj: nape.dynamics.Arbiter): boolean;
            public pop(): nape.dynamics.Arbiter;
            public unshift(obj: nape.dynamics.Arbiter): boolean;
            public shift(): nape.dynamics.Arbiter;
            public remove(obj: nape.dynamics.Arbiter): boolean;
            public clear(): void;
            public at(index: number): nape.dynamics.Arbiter;
            constructor();
        }
    }
    export module geom {
        export class ZPP_AABB {
            public _invalidate: (__0: zpp_nape.geom.ZPP_AABB) => void;
            public _validate: () => void;
            public _immutable: boolean;
            public validate: () => void;
            public invalidate: () => void;
            public outer: nape.geom.AABB;
            public next: zpp_nape.geom.ZPP_AABB;
            public alloc: () => void;
            public free: () => void;
            public copy: () => zpp_nape.geom.ZPP_AABB;
            public width: () => number;
            public height: () => number;
            public perimeter: () => number;
            public minx: number;
            public miny: number;
            public wrap_min: nape.geom.Vec2;
            public maxx: number;
            public maxy: number;
            public wrap_max: nape.geom.Vec2;
            public intersectX: (x: zpp_nape.geom.ZPP_AABB) => boolean;
            public intersectY: (x: zpp_nape.geom.ZPP_AABB) => boolean;
            public intersect: (x: zpp_nape.geom.ZPP_AABB) => boolean;
            public combine: (x: zpp_nape.geom.ZPP_AABB) => void;
            public contains: (x: zpp_nape.geom.ZPP_AABB) => boolean;
            public containsPoint: (v: zpp_nape.geom.ZPP_Vec2) => boolean;
            public setCombine: (a: zpp_nape.geom.ZPP_AABB, b: zpp_nape.geom.ZPP_AABB) => void;
            public setExpand: (a: zpp_nape.geom.ZPP_AABB, fatten: number) => void;
            public setExpandPoint: (x: number, y: number) => void;
            public static zpp_pool: zpp_nape.geom.ZPP_AABB;
            public static get: (minx: number, miny: number, maxx: number, maxy: number) => zpp_nape.geom.ZPP_AABB;
            public wrapper(): nape.geom.AABB;
            public getmin(): nape.geom.Vec2;
            public dom_min(): void;
            public mod_min(min: zpp_nape.geom.ZPP_Vec2): void;
            public getmax(): nape.geom.Vec2;
            public dom_max(): void;
            public mod_max(max: zpp_nape.geom.ZPP_Vec2): void;
            public toString(): String;
            constructor();
        }
        export class ZPP_Collide {
            public static flowpoly: zpp_nape.util.ZNPList_ZPP_Vec2;
            public static flowsegs: zpp_nape.util.ZNPList_ZPP_Vec2;
            public static circleContains(c: zpp_nape.shape.ZPP_Circle, p: zpp_nape.geom.ZPP_Vec2): boolean;
            public static polyContains(s: zpp_nape.shape.ZPP_Polygon, p: zpp_nape.geom.ZPP_Vec2): boolean;
            public static shapeContains(s: zpp_nape.shape.ZPP_Shape, p: zpp_nape.geom.ZPP_Vec2): boolean;
            public static bodyContains(b: zpp_nape.phys.ZPP_Body, p: zpp_nape.geom.ZPP_Vec2): boolean;
            public static containTest(s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape): boolean;
            public static contactCollide(s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, arb: zpp_nape.dynamics.ZPP_ColArbiter, rev: boolean): boolean;
            public static testCollide_safe(s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape): boolean;
            public static testCollide(s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape): boolean;
            public static flowCollide(s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, arb: zpp_nape.dynamics.ZPP_FluidArbiter): boolean;
        }
        export class ZPP_Convex {
            public static optimise(P: zpp_nape.geom.ZPP_PartitionedPoly): void;
        }
        export class ZPP_ConvexRayResult {
            public normal: nape.geom.Vec2;
            public shape: nape.shape.Shape;
            public convex: nape.geom.ConvexResult;
            public position: nape.geom.Vec2;
            public ray: nape.geom.RayResult;
            public inner: boolean;
            public next: zpp_nape.geom.ZPP_ConvexRayResult;
            public toiDistance: number;
            public disposed: () => void;
            public static internal: boolean;
            public static getRay(normal: nape.geom.Vec2, time: number, inner: boolean, shape: nape.shape.Shape): nape.geom.RayResult;
            public static getConvex(normal: nape.geom.Vec2, position: nape.geom.Vec2, toiDistance: number, shape: nape.shape.Shape): nape.geom.ConvexResult;
            public free(): void;
            constructor();
        }
        export class ZPP_CutVert {
            public prev: zpp_nape.geom.ZPP_CutVert;
            public next: zpp_nape.geom.ZPP_CutVert;
            public posx: number;
            public posy: number;
            public vert: zpp_nape.geom.ZPP_GeomVert;
            public value: number;
            public positive: boolean;
            public parent: zpp_nape.geom.ZPP_CutVert;
            public rank: number;
            public used: boolean;
            public alloc: () => void;
            public free: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_CutVert;
            public static path: (poly: zpp_nape.geom.ZPP_GeomVert) => zpp_nape.geom.ZPP_CutVert;
            constructor();
        }
        export class ZPP_CutInt {
            public next: zpp_nape.geom.ZPP_CutInt;
            public time: number;
            public virtualint: boolean;
            public vertex: boolean;
            public path0: zpp_nape.geom.ZPP_CutVert;
            public end: zpp_nape.geom.ZPP_GeomVert;
            public start: zpp_nape.geom.ZPP_GeomVert;
            public path1: zpp_nape.geom.ZPP_CutVert;
            public alloc: () => void;
            public free: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_CutInt;
            public static get: (time: number, end?: zpp_nape.geom.ZPP_GeomVert, start?: zpp_nape.geom.ZPP_GeomVert, path0?: zpp_nape.geom.ZPP_CutVert, path1?: zpp_nape.geom.ZPP_CutVert, virtualint?: boolean, vertex?: boolean) => zpp_nape.geom.ZPP_CutInt;
            constructor();
        }
        export class ZPP_Cutter {
            public static run(P: zpp_nape.geom.ZPP_GeomVert, _start: nape.geom.Vec2, _end: nape.geom.Vec2, bstart: boolean, bend: boolean, output: nape.geom.GeomPolyList): nape.geom.GeomPolyList;
        }
        export class ZPP_Geom {
            public static validateShape(s: zpp_nape.shape.ZPP_Shape): void;
        }
        export class ZPP_GeomVert {
            public x: number;
            public y: number;
            public prev: zpp_nape.geom.ZPP_GeomVert;
            public next: zpp_nape.geom.ZPP_GeomVert;
            public wrap: nape.geom.Vec2;
            public forced: boolean;
            public free: () => void;
            public alloc: () => void;
            public wrapper: () => nape.geom.Vec2;
            public modwrap: (n: zpp_nape.geom.ZPP_Vec2) => void;
            public getwrap: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_GeomVert;
            public static get: (x: number, y: number) => zpp_nape.geom.ZPP_GeomVert;
            constructor();
        }
        export class ZPP_GeomPoly {
            public outer: nape.geom.GeomPoly;
            public vertices: zpp_nape.geom.ZPP_GeomVert;
            constructor(outer: nape.geom.GeomPoly);
        }
        export class ZPP_GeomVertexIterator {
            public ptr: zpp_nape.geom.ZPP_GeomVert;
            public start: zpp_nape.geom.ZPP_GeomVert;
            public first: boolean;
            public forward: boolean;
            public outer: nape.geom.GeomVertexIterator;
            public next: zpp_nape.geom.ZPP_GeomVertexIterator;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_GeomVertexIterator;
            public static internal: boolean;
            public static get(poly: zpp_nape.geom.ZPP_GeomVert, forward: boolean): nape.geom.GeomVertexIterator;
        }
        export class ZPP_MarchSpan {
            public parent: zpp_nape.geom.ZPP_MarchSpan;
            public rank: number;
            public out: boolean;
            public next: zpp_nape.geom.ZPP_MarchSpan;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_MarchSpan;
            constructor();
        }
        export class ZPP_MarchPair {
            public p1: zpp_nape.geom.ZPP_GeomVert;
            public key1: number;
            public okey1: number;
            public p2: zpp_nape.geom.ZPP_GeomVert;
            public key2: number;
            public okey2: number;
            public pr: zpp_nape.geom.ZPP_GeomVert;
            public keyr: number;
            public okeyr: number;
            public pd: zpp_nape.geom.ZPP_GeomVert;
            public span1: zpp_nape.geom.ZPP_MarchSpan;
            public span2: zpp_nape.geom.ZPP_MarchSpan;
            public spanr: zpp_nape.geom.ZPP_MarchSpan;
            public next: zpp_nape.geom.ZPP_MarchPair;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_MarchPair;
            constructor();
        }
        export class ZPP_MarchingSquares {
            public static look_march: any[];
            public static run(iso: nape.geom.IsoFunctionDef, bx0: number, by0: number, bx1: number, by1: number, cell: nape.geom.Vec2, quality: number, combine: boolean, ret: nape.geom.GeomPolyList): void;
        }
        export class ZPP_Mat23 {
            public outer: nape.geom.Mat23;
            public a: number;
            public b: number;
            public c: number;
            public d: number;
            public tx: number;
            public ty: number;
            public _invalidate: () => void;
            public invalidate: () => void;
            public set: (m: zpp_nape.geom.ZPP_Mat23) => void;
            public next: zpp_nape.geom.ZPP_Mat23;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_Mat23;
            public static get(): zpp_nape.geom.ZPP_Mat23;
            public static identity(): zpp_nape.geom.ZPP_Mat23;
            public wrapper(): nape.geom.Mat23;
            public setas(a: number, b: number, c: number, d: number, tx: number, ty: number): void;
            constructor();
        }
        export class ZPP_MatMN {
            public outer: nape.geom.MatMN;
            public m: number;
            public n: number;
            public x: number[];
            constructor(m: number, n: number);
        }
        export class ZPP_Monotone {
            public static sharedPPoly: zpp_nape.geom.ZPP_PartitionedPoly;
            public static getShared: () => zpp_nape.geom.ZPP_PartitionedPoly;
            public static isMonotone(P: zpp_nape.geom.ZPP_GeomVert): boolean;
            public static decompose(P: zpp_nape.geom.ZPP_GeomVert, poly?: zpp_nape.geom.ZPP_PartitionedPoly): zpp_nape.geom.ZPP_PartitionedPoly;
        }
        export class ZPP_PartitionVertex {
            public id: number;
            public mag: number;
            public x: number;
            public y: number;
            public forced: boolean;
            public diagonals: zpp_nape.util.ZNPList_ZPP_PartitionVertex;
            public type: number;
            public helper: zpp_nape.geom.ZPP_PartitionVertex;
            public rightchain: boolean;
            public next: zpp_nape.geom.ZPP_PartitionVertex;
            public prev: zpp_nape.geom.ZPP_PartitionVertex;
            public alloc: () => void;
            public free: () => void;
            public copy: () => zpp_nape.geom.ZPP_PartitionVertex;
            public node: zpp_nape.util.ZPP_Set_ZPP_PartitionVertex;
            public static zpp_pool: zpp_nape.geom.ZPP_PartitionVertex;
            public static get: (x: zpp_nape.geom.ZPP_GeomVert) => zpp_nape.geom.ZPP_PartitionVertex;
            public static vert_lt(edge: zpp_nape.geom.ZPP_PartitionVertex, vert: zpp_nape.geom.ZPP_PartitionVertex): boolean;
            public static edge_swap(p: zpp_nape.geom.ZPP_PartitionVertex, q: zpp_nape.geom.ZPP_PartitionVertex): void;
            public static edge_lt(p: zpp_nape.geom.ZPP_PartitionVertex, q: zpp_nape.geom.ZPP_PartitionVertex): boolean;
            public sort(): void;
            constructor();
        }
        export class ZPP_PartitionedPoly {
            public vertices: zpp_nape.geom.ZPP_PartitionVertex;
            public next: zpp_nape.geom.ZPP_PartitionedPoly;
            public alloc: () => void;
            public free: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_PartitionedPoly;
            public static sharedPPList: zpp_nape.util.ZNPList_ZPP_PartitionedPoly;
            public static getSharedPP: () => zpp_nape.util.ZNPList_ZPP_PartitionedPoly;
            public static sharedGVList: zpp_nape.util.ZNPList_ZPP_GeomVert;
            public static getShared: () => zpp_nape.util.ZNPList_ZPP_GeomVert;
            public init(P?: zpp_nape.geom.ZPP_GeomVert): void;
            public remove_collinear_vertices(): boolean;
            public add_diagonal(p: zpp_nape.geom.ZPP_PartitionVertex, q: zpp_nape.geom.ZPP_PartitionVertex): void;
            public extract_partitions(ret?: zpp_nape.util.ZNPList_ZPP_PartitionedPoly): zpp_nape.util.ZNPList_ZPP_PartitionedPoly;
            public extract(ret?: zpp_nape.util.ZNPList_ZPP_GeomVert): zpp_nape.util.ZNPList_ZPP_GeomVert;
            constructor(P?: zpp_nape.geom.ZPP_GeomVert);
        }
        export class ZPP_Ray {
            public origin: nape.geom.Vec2;
            public direction: nape.geom.Vec2;
            public maxdist: number;
            public userData: any;
            public originx: number;
            public originy: number;
            public dirx: number;
            public diry: number;
            public idirx: number;
            public idiry: number;
            public normalx: number;
            public normaly: number;
            public absnormalx: number;
            public absnormaly: number;
            public zip_dir: boolean;
            public invalidate_dir: () => void;
            public static internal: boolean;
            public validate_dir(): void;
            public rayAABB(): zpp_nape.geom.ZPP_AABB;
            public aabbtest(a: zpp_nape.geom.ZPP_AABB): boolean;
            public aabbsect(a: zpp_nape.geom.ZPP_AABB): number;
            public circlesect(c: zpp_nape.shape.ZPP_Circle, inner: boolean, mint: number): nape.geom.RayResult;
            public circlesect2(c: zpp_nape.shape.ZPP_Circle, inner: boolean, list: nape.geom.RayResultList): void;
            public polysect(p: zpp_nape.shape.ZPP_Polygon, inner: boolean, mint: number): nape.geom.RayResult;
            public polysect2(p: zpp_nape.shape.ZPP_Polygon, inner: boolean, list: nape.geom.RayResultList): void;
            constructor();
        }
        export class ZPP_SimpleVert {
            public forced: boolean;
            public x: number;
            public y: number;
            public links: zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public id: number;
            public next: zpp_nape.geom.ZPP_SimpleVert;
            public node: zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_SimpleVert;
            public static get: (x: number, y: number) => zpp_nape.geom.ZPP_SimpleVert;
            public static less_xy(p: zpp_nape.geom.ZPP_SimpleVert, q: zpp_nape.geom.ZPP_SimpleVert): boolean;
            public static swap_nodes(p: zpp_nape.geom.ZPP_SimpleVert, q: zpp_nape.geom.ZPP_SimpleVert): void;
        }
        export class ZPP_SimpleSeg {
            public left: zpp_nape.geom.ZPP_SimpleVert;
            public right: zpp_nape.geom.ZPP_SimpleVert;
            public vertices: zpp_nape.util.ZPP_Set_ZPP_SimpleVert;
            public id: number;
            public next: zpp_nape.geom.ZPP_SimpleSeg;
            public free: () => void;
            public alloc: () => void;
            public prev: zpp_nape.geom.ZPP_SimpleSeg;
            public node: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public static zpp_pool: zpp_nape.geom.ZPP_SimpleSeg;
            public static get(left: zpp_nape.geom.ZPP_SimpleVert, right: zpp_nape.geom.ZPP_SimpleVert): zpp_nape.geom.ZPP_SimpleSeg;
            public less_xy(a: zpp_nape.geom.ZPP_SimpleVert, b: zpp_nape.geom.ZPP_SimpleVert): boolean;
        }
        export class ZPP_SimpleEvent {
            public type: number;
            public vertex: zpp_nape.geom.ZPP_SimpleVert;
            public segment: zpp_nape.geom.ZPP_SimpleSeg;
            public segment2: zpp_nape.geom.ZPP_SimpleSeg;
            public node: zpp_nape.util.ZPP_Set_ZPP_SimpleEvent;
            public next: zpp_nape.geom.ZPP_SimpleEvent;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_SimpleEvent;
            public static get: (v: zpp_nape.geom.ZPP_SimpleVert) => zpp_nape.geom.ZPP_SimpleEvent;
            public static swap_nodes(a: zpp_nape.geom.ZPP_SimpleEvent, b: zpp_nape.geom.ZPP_SimpleEvent): void;
            public static less_xy(a: zpp_nape.geom.ZPP_SimpleEvent, b: zpp_nape.geom.ZPP_SimpleEvent): boolean;
        }
        export class ZPP_SimpleSweep {
            public sweepx: number;
            public tree: zpp_nape.util.ZPP_Set_ZPP_SimpleSeg;
            public swap_nodes(p: zpp_nape.geom.ZPP_SimpleSeg, q: zpp_nape.geom.ZPP_SimpleSeg): void;
            public edge_lt(p: zpp_nape.geom.ZPP_SimpleSeg, q: zpp_nape.geom.ZPP_SimpleSeg): boolean;
            public clear(): void;
            public add(e: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.geom.ZPP_SimpleSeg;
            public remove(e: zpp_nape.geom.ZPP_SimpleSeg): void;
            public intersect(p: zpp_nape.geom.ZPP_SimpleSeg, q: zpp_nape.geom.ZPP_SimpleSeg): boolean;
            public intersection(p: zpp_nape.geom.ZPP_SimpleSeg, q: zpp_nape.geom.ZPP_SimpleSeg): zpp_nape.geom.ZPP_SimpleEvent;
            constructor();
        }
        export class ZPP_Simple {
            public static decompose(poly: zpp_nape.geom.ZPP_GeomVert, rets?: zpp_nape.util.ZNPList_ZPP_GeomVert): zpp_nape.util.ZNPList_ZPP_GeomVert;
            public static clip_polygon(vertices: zpp_nape.util.ZPP_Set_ZPP_SimpleVert, rets: zpp_nape.util.ZNPList_ZPP_GeomVert): void;
            public static isSimple(poly: zpp_nape.geom.ZPP_GeomVert): boolean;
        }
        export class ZPP_SimplifyV {
            public x: number;
            public y: number;
            public next: zpp_nape.geom.ZPP_SimplifyV;
            public prev: zpp_nape.geom.ZPP_SimplifyV;
            public flag: boolean;
            public forced: boolean;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_SimplifyV;
            public static get: (v: zpp_nape.geom.ZPP_GeomVert) => zpp_nape.geom.ZPP_SimplifyV;
            constructor();
        }
        export class ZPP_SimplifyP {
            public next: zpp_nape.geom.ZPP_SimplifyP;
            public min: zpp_nape.geom.ZPP_SimplifyV;
            public max: zpp_nape.geom.ZPP_SimplifyV;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.geom.ZPP_SimplifyP;
            public static get: (min: zpp_nape.geom.ZPP_SimplifyV, max: zpp_nape.geom.ZPP_SimplifyV) => zpp_nape.geom.ZPP_SimplifyP;
            constructor();
        }
        export class ZPP_Simplify {
            public static lessval: (a: zpp_nape.geom.ZPP_SimplifyV, b: zpp_nape.geom.ZPP_SimplifyV) => number;
            public static less: (a: zpp_nape.geom.ZPP_SimplifyV, b: zpp_nape.geom.ZPP_SimplifyV) => boolean;
            public static distance(v: zpp_nape.geom.ZPP_SimplifyV, a: zpp_nape.geom.ZPP_SimplifyV, b: zpp_nape.geom.ZPP_SimplifyV): number;
            public static simplify(P: zpp_nape.geom.ZPP_GeomVert, epsilon: number): zpp_nape.geom.ZPP_GeomVert;
        }
        export class ZPP_ToiEvent {
            public next: zpp_nape.geom.ZPP_ToiEvent;
            public alloc: () => void;
            public free: () => void;
            public toi: number;
            public s1: zpp_nape.shape.ZPP_Shape;
            public s2: zpp_nape.shape.ZPP_Shape;
            public arbiter: zpp_nape.dynamics.ZPP_ColArbiter;
            public frozen1: boolean;
            public frozen2: boolean;
            public c1: zpp_nape.geom.ZPP_Vec2;
            public c2: zpp_nape.geom.ZPP_Vec2;
            public axis: zpp_nape.geom.ZPP_Vec2;
            public slipped: boolean;
            public failed: boolean;
            public kinematic: boolean;
            public static zpp_pool: zpp_nape.geom.ZPP_ToiEvent;
            constructor();
        }
        export class ZPP_SweepDistance {
            public static distance: (s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, w1: zpp_nape.geom.ZPP_Vec2, w2: zpp_nape.geom.ZPP_Vec2, axis: zpp_nape.geom.ZPP_Vec2, upperBound?: number) => number;
            public static dynamicSweep(toi: zpp_nape.geom.ZPP_ToiEvent, timeStep: number, lowerBound: number, negRadius: number, userAPI?: boolean): void;
            public static staticSweep(toi: zpp_nape.geom.ZPP_ToiEvent, timeStep: number, lowerBound: number, negRadius: number): void;
            public static distanceBody(b1: zpp_nape.phys.ZPP_Body, b2: zpp_nape.phys.ZPP_Body, w1: zpp_nape.geom.ZPP_Vec2, w2: zpp_nape.geom.ZPP_Vec2): number;
        }
        export class ZPP_PartitionPair {
            public next: zpp_nape.geom.ZPP_PartitionPair;
            public elem: () => zpp_nape.geom.ZPP_PartitionPair;
            public begin: () => zpp_nape.geom.ZPP_PartitionPair;
            public _inuse: boolean;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.geom.ZPP_PartitionPair) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_PartitionPair) => zpp_nape.geom.ZPP_PartitionPair;
            public inlined_insert: (cur: zpp_nape.geom.ZPP_PartitionPair, o: zpp_nape.geom.ZPP_PartitionPair) => zpp_nape.geom.ZPP_PartitionPair;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_PartitionPair;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_PartitionPair) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_PartitionPair) => boolean;
            public inlined_erase: (pre: zpp_nape.geom.ZPP_PartitionPair) => zpp_nape.geom.ZPP_PartitionPair;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_PartitionPair) => boolean;
            public front: () => zpp_nape.geom.ZPP_PartitionPair;
            public free: () => void;
            public alloc: () => void;
            public a: zpp_nape.geom.ZPP_PartitionVertex;
            public b: zpp_nape.geom.ZPP_PartitionVertex;
            public id: number;
            public di: number;
            public node: zpp_nape.util.ZPP_Set_ZPP_PartitionPair;
            public static zpp_pool: zpp_nape.geom.ZPP_PartitionPair;
            public static get: (a: zpp_nape.geom.ZPP_PartitionVertex, b: zpp_nape.geom.ZPP_PartitionVertex) => zpp_nape.geom.ZPP_PartitionPair;
            public static edge_swap(a: zpp_nape.geom.ZPP_PartitionPair, b: zpp_nape.geom.ZPP_PartitionPair): void;
            public static edge_lt(a: zpp_nape.geom.ZPP_PartitionPair, b: zpp_nape.geom.ZPP_PartitionPair): boolean;
            public add(o: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.geom.ZPP_PartitionPair;
            public addAll(x: zpp_nape.geom.ZPP_PartitionPair): void;
            public insert(cur: zpp_nape.geom.ZPP_PartitionPair, o: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.geom.ZPP_PartitionPair;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_PartitionPair;
            public remove(obj: zpp_nape.geom.ZPP_PartitionPair): void;
            public try_remove(obj: zpp_nape.geom.ZPP_PartitionPair): boolean;
            public erase(pre: zpp_nape.geom.ZPP_PartitionPair): zpp_nape.geom.ZPP_PartitionPair;
            public splice(pre: zpp_nape.geom.ZPP_PartitionPair, n: number): zpp_nape.geom.ZPP_PartitionPair;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_PartitionPair): boolean;
            public back(): zpp_nape.geom.ZPP_PartitionPair;
            public iterator_at(ind: number): zpp_nape.geom.ZPP_PartitionPair;
            public at(ind: number): zpp_nape.geom.ZPP_PartitionPair;
            constructor();
        }
        export class ZPP_Triangular {
            public static delaunay(A: zpp_nape.geom.ZPP_PartitionVertex, B: zpp_nape.geom.ZPP_PartitionVertex, C: zpp_nape.geom.ZPP_PartitionVertex, D: zpp_nape.geom.ZPP_PartitionVertex): boolean;
            public static optimise(P: zpp_nape.geom.ZPP_PartitionedPoly): void;
            public static triangulate(P: zpp_nape.geom.ZPP_PartitionedPoly): zpp_nape.geom.ZPP_PartitionedPoly;
        }
        export class ZPP_Vec2 {
            public _invalidate: (__0: zpp_nape.geom.ZPP_Vec2) => void;
            public _validate: () => void;
            public validate: () => void;
            public invalidate: () => void;
            public _immutable: boolean;
            public _isimmutable: () => void;
            public immutable: () => void;
            public outer: nape.geom.Vec2;
            public wrapper: () => nape.geom.Vec2;
            public weak: boolean;
            public free: () => void;
            public alloc: () => void;
            public next: zpp_nape.geom.ZPP_Vec2;
            public elem: () => zpp_nape.geom.ZPP_Vec2;
            public begin: () => zpp_nape.geom.ZPP_Vec2;
            public _inuse: boolean;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.geom.ZPP_Vec2) => void;
            public inlined_add: (o: zpp_nape.geom.ZPP_Vec2) => zpp_nape.geom.ZPP_Vec2;
            public inlined_insert: (cur: zpp_nape.geom.ZPP_Vec2, o: zpp_nape.geom.ZPP_Vec2) => zpp_nape.geom.ZPP_Vec2;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.geom.ZPP_Vec2;
            public inlined_remove: (obj: zpp_nape.geom.ZPP_Vec2) => void;
            public inlined_try_remove: (obj: zpp_nape.geom.ZPP_Vec2) => boolean;
            public inlined_erase: (pre: zpp_nape.geom.ZPP_Vec2) => zpp_nape.geom.ZPP_Vec2;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.geom.ZPP_Vec2) => boolean;
            public front: () => zpp_nape.geom.ZPP_Vec2;
            public x: number;
            public y: number;
            public copy: () => zpp_nape.geom.ZPP_Vec2;
            public static zpp_pool: zpp_nape.geom.ZPP_Vec2;
            public static get: (x: number, y: number, immutable?: boolean) => zpp_nape.geom.ZPP_Vec2;
            public add(o: zpp_nape.geom.ZPP_Vec2): zpp_nape.geom.ZPP_Vec2;
            public addAll(x: zpp_nape.geom.ZPP_Vec2): void;
            public insert(cur: zpp_nape.geom.ZPP_Vec2, o: zpp_nape.geom.ZPP_Vec2): zpp_nape.geom.ZPP_Vec2;
            public pop(): void;
            public pop_unsafe(): zpp_nape.geom.ZPP_Vec2;
            public remove(obj: zpp_nape.geom.ZPP_Vec2): void;
            public try_remove(obj: zpp_nape.geom.ZPP_Vec2): boolean;
            public erase(pre: zpp_nape.geom.ZPP_Vec2): zpp_nape.geom.ZPP_Vec2;
            public splice(pre: zpp_nape.geom.ZPP_Vec2, n: number): zpp_nape.geom.ZPP_Vec2;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.geom.ZPP_Vec2): boolean;
            public back(): zpp_nape.geom.ZPP_Vec2;
            public iterator_at(ind: number): zpp_nape.geom.ZPP_Vec2;
            public at(ind: number): zpp_nape.geom.ZPP_Vec2;
            public toString(): String;
            constructor();
        }
        export class ZPP_Vec3 {
            public outer: nape.geom.Vec3;
            public x: number;
            public y: number;
            public z: number;
            public immutable: boolean;
            public _validate: () => void;
            public validate: () => void;
            constructor();
        }
        export class ZPP_VecMath {
            public static vec_dsq: (ax: number, ay: number, bx: number, by: number) => number;
            public static vec_distance: (ax: number, ay: number, bx: number, by: number) => number;
        }
    }
    export module phys {
        export class ZPP_Interactor {
            public outer_i: nape.phys.Interactor;
            public id: number;
            public userData: any;
            public ishape: zpp_nape.shape.ZPP_Shape;
            public ibody: zpp_nape.phys.ZPP_Body;
            public icompound: zpp_nape.phys.ZPP_Compound;
            public isShape: () => boolean;
            public isBody: () => boolean;
            public isCompound: () => boolean;
            public cbsets: zpp_nape.util.ZNPList_ZPP_CallbackSet;
            public getSpace: () => zpp_nape.space.ZPP_Space;
            public group: zpp_nape.dynamics.ZPP_InteractionGroup;
            public cbTypes: zpp_nape.util.ZNPList_ZPP_CbType;
            public cbSet: zpp_nape.callbacks.ZPP_CbSet;
            public wrap_cbTypes: nape.callbacks.CbTypeList;
            public lookup_group: () => zpp_nape.dynamics.ZPP_InteractionGroup;
            public static int_callback: (set: zpp_nape.space.ZPP_CallbackSet, x: zpp_nape.callbacks.ZPP_InteractionListener, cb: zpp_nape.callbacks.ZPP_Callback) => void;
            public static get(i1: zpp_nape.phys.ZPP_Interactor, i2: zpp_nape.phys.ZPP_Interactor): zpp_nape.space.ZPP_CallbackSet;
            public __iaddedToSpace(): void;
            public __iremovedFromSpace(): void;
            public wake(): void;
            public setupcbTypes(): void;
            public insert_cbtype(cb: zpp_nape.callbacks.ZPP_CbType): void;
            public alloc_cbSet(): void;
            public dealloc_cbSet(): void;
            public setGroup(group: zpp_nape.dynamics.ZPP_InteractionGroup): void;
            public immutable_midstep(n: String): void;
            public copyto(ret: nape.phys.Interactor): void;
            constructor();
        }
        export class ZPP_Body extends zpp_nape.phys.ZPP_Interactor {
            public outer: nape.phys.Body;
            public world: boolean;
            public type: number;
            public isStatic: () => boolean;
            public isDynamic: () => boolean;
            public isKinematic: () => boolean;
            public compound: zpp_nape.phys.ZPP_Compound;
            public shapes: zpp_nape.util.ZNPList_ZPP_Shape;
            public wrap_shapes: nape.shape.ShapeList;
            public space: zpp_nape.space.ZPP_Space;
            public arbiters: zpp_nape.util.ZNPList_ZPP_Arbiter;
            public wrap_arbiters: nape.dynamics.ArbiterList;
            public constraints: zpp_nape.util.ZNPList_ZPP_Constraint;
            public wrap_constraints: nape.constraint.ConstraintList;
            public component: zpp_nape.space.ZPP_Component;
            public graph_depth: number;
            public sweepTime: number;
            public sweep_angvel: number;
            public sweepFrozen: boolean;
            public sweepRadius: number;
            public bullet: boolean;
            public bulletEnabled: boolean;
            public disableCCD: boolean;
            public sweepIntegrate: (dt: number) => void;
            public sweepValidate: (s: zpp_nape.shape.ZPP_Shape) => void;
            public pre_posx: number;
            public pre_posy: number;
            public posx: number;
            public posy: number;
            public wrap_pos: nape.geom.Vec2;
            public velx: number;
            public vely: number;
            public wrap_vel: nape.geom.Vec2;
            public forcex: number;
            public forcey: number;
            public wrap_force: nape.geom.Vec2;
            public kinvelx: number;
            public kinvely: number;
            public wrap_kinvel: nape.geom.Vec2;
            public svelx: number;
            public svely: number;
            public wrap_svel: nape.geom.Vec2;
            public invalidate_pos: () => void;
            public wrapcvel: nape.geom.Vec3;
            public angvel: number;
            public torque: number;
            public kinangvel: number;
            public pre_rot: number;
            public rot: number;
            public invalidate_rot: () => void;
            public axisx: number;
            public axisy: number;
            public zip_axis: boolean;
            public validate_axis: () => void;
            public quick_validate_axis: () => void;
            public delta_rot: (dr: number) => void;
            public kinematicDelaySleep: boolean;
            public mass: number;
            public zip_mass: boolean;
            public massMode: number;
            public imass: number;
            public smass: number;
            public cmass: number;
            public nomove: boolean;
            public gravMass: number;
            public zip_gravMass: boolean;
            public gravMassMode: number;
            public gravMassScale: number;
            public zip_gravMassScale: boolean;
            public inertiaMode: number;
            public inertia: number;
            public zip_inertia: boolean;
            public cinertia: number;
            public iinertia: number;
            public sinertia: number;
            public norotate: boolean;
            public invalidate_wake: () => void;
            public aabb: zpp_nape.geom.ZPP_AABB;
            public zip_aabb: boolean;
            public validate_aabb: () => void;
            public invalidate_aabb: () => void;
            public localCOMx: number;
            public localCOMy: number;
            public zip_localCOM: boolean;
            public worldCOMx: number;
            public worldCOMy: number;
            public zip_worldCOM: boolean;
            public wrap_localCOM: nape.geom.Vec2;
            public wrap_worldCOM: nape.geom.Vec2;
            public invalidate_localCOM: () => void;
            public invalidate_worldCOM: () => void;
            public __immutable_midstep: (name: String) => void;
            public static types: any[];
            public static __static(): nape.phys.Body;
            public invalidate_type(): void;
            public invalidate_shapes(): void;
            public connectedBodies(depth: number, output: nape.phys.BodyList): nape.phys.BodyList;
            public interactingBodies(arbiter_type: number, depth: number, output: nape.phys.BodyList): nape.phys.BodyList;
            public atRest(dt: number): boolean;
            public refreshArbiters(): void;
            public setupPosition(): void;
            public setupVelocity(): void;
            public setupkinvel(): void;
            public setupsvel(): void;
            public setupForce(): void;
            public setup_cvel(): void;
            public invalidate_mass(): void;
            public validate_mass(): void;
            public invalidate_gravMass(): void;
            public validate_gravMass(): void;
            public invalidate_gravMassScale(): void;
            public validate_gravMassScale(): void;
            public invalidate_inertia(): void;
            public validate_inertia(): void;
            public validate_localCOM(): void;
            public validate_worldCOM(): void;
            public getlocalCOM(): void;
            public getworldCOM(): void;
            public clear(): void;
            public addedToSpace(): void;
            public removedFromSpace(): void;
            public copy(): nape.phys.Body;
            constructor();
        }
        export class ZPP_Compound extends zpp_nape.phys.ZPP_Interactor {
            public outer: nape.phys.Compound;
            public bodies: zpp_nape.util.ZNPList_ZPP_Body;
            public constraints: zpp_nape.util.ZNPList_ZPP_Constraint;
            public compounds: zpp_nape.util.ZNPList_ZPP_Compound;
            public wrap_bodies: nape.phys.BodyList;
            public wrap_constraints: nape.constraint.ConstraintList;
            public wrap_compounds: nape.phys.CompoundList;
            public depth: number;
            public compound: zpp_nape.phys.ZPP_Compound;
            public space: zpp_nape.space.ZPP_Space;
            public __imutable_midstep(name: String): void;
            public addedToSpace(): void;
            public removedFromSpace(): void;
            public breakApart(): void;
            public copy(dict?: any[], todo?: any[]): nape.phys.Compound;
            constructor();
        }
        export class ZPP_FluidProperties {
            public next: zpp_nape.phys.ZPP_FluidProperties;
            public userData: any;
            public outer: nape.phys.FluidProperties;
            public free: () => void;
            public alloc: () => void;
            public shapes: zpp_nape.util.ZNPList_ZPP_Shape;
            public wrap_shapes: nape.shape.ShapeList;
            public feature_cons: () => void;
            public addShape: (shape: zpp_nape.shape.ZPP_Shape) => void;
            public remShape: (shape: zpp_nape.shape.ZPP_Shape) => void;
            public viscosity: number;
            public density: number;
            public gravityx: number;
            public gravityy: number;
            public wrap_gravity: nape.geom.Vec2;
            public static zpp_pool: zpp_nape.phys.ZPP_FluidProperties;
            public wrapper(): nape.phys.FluidProperties;
            public copy(): zpp_nape.phys.ZPP_FluidProperties;
            public getgravity(): void;
            public invalidate(): void;
            constructor();
        }
        export class ZPP_Material {
            public next: zpp_nape.phys.ZPP_Material;
            public userData: any;
            public outer: nape.phys.Material;
            public free: () => void;
            public alloc: () => void;
            public shapes: zpp_nape.util.ZNPList_ZPP_Shape;
            public wrap_shapes: nape.shape.ShapeList;
            public feature_cons: () => void;
            public addShape: (shape: zpp_nape.shape.ZPP_Shape) => void;
            public remShape: (shape: zpp_nape.shape.ZPP_Shape) => void;
            public dynamicFriction: number;
            public staticFriction: number;
            public density: number;
            public elasticity: number;
            public rollingFriction: number;
            public static zpp_pool: zpp_nape.phys.ZPP_Material;
            public static WAKE: number;
            public static PROPS: number;
            public static ANGDRAG: number;
            public static ARBITERS: number;
            public wrapper(): nape.phys.Material;
            public copy(): zpp_nape.phys.ZPP_Material;
            public set(x: zpp_nape.phys.ZPP_Material): void;
            public invalidate(x: number): void;
            constructor();
        }
    }
    export module shape {
        export class ZPP_Shape extends zpp_nape.phys.ZPP_Interactor {
            public outer: nape.shape.Shape;
            public body: zpp_nape.phys.ZPP_Body;
            public type: number;
            public isCircle: () => boolean;
            public isPolygon: () => boolean;
            public area: number;
            public zip_area_inertia: boolean;
            public inertia: number;
            public angDrag: number;
            public zip_angDrag: boolean;
            public localCOMx: number;
            public localCOMy: number;
            public zip_localCOM: boolean;
            public worldCOMx: number;
            public worldCOMy: number;
            public zip_worldCOM: boolean;
            public wrap_localCOM: nape.geom.Vec2;
            public wrap_worldCOM: nape.geom.Vec2;
            public sweepRadius: number;
            public zip_sweepRadius: boolean;
            public sweepCoef: number;
            public invalidate_sweepRadius: () => void;
            public circle: zpp_nape.shape.ZPP_Circle;
            public polygon: zpp_nape.shape.ZPP_Polygon;
            public refmaterial: zpp_nape.phys.ZPP_Material;
            public material: zpp_nape.phys.ZPP_Material;
            public filter: zpp_nape.dynamics.ZPP_InteractionFilter;
            public fluidProperties: zpp_nape.phys.ZPP_FluidProperties;
            public fluidEnabled: boolean;
            public sensorEnabled: boolean;
            public sweep: zpp_nape.space.ZPP_SweepData;
            public node: zpp_nape.space.ZPP_AABBNode;
            public pairs: zpp_nape.util.ZNPList_ZPP_AABBPair;
            public aabb: zpp_nape.geom.ZPP_AABB;
            public zip_aabb: boolean;
            public validate_aabb: () => void;
            public force_validate_aabb: () => void;
            public invalidate_aabb: () => void;
            public validate_localCOM: () => void;
            public validate_worldCOM: () => void;
            public static types: any[];
            public validate_sweepRadius(): void;
            public clear(): void;
            public validate_area_inertia(): void;
            public validate_angDrag(): void;
            public getworldCOM(): void;
            public invalidate_area_inertia(): void;
            public invalidate_angDrag(): void;
            public invalidate_localCOM(): void;
            public invalidate_worldCOM(): void;
            public invalidate_material(flags: number): void;
            public invalidate_filter(): void;
            public invalidate_fluidprops(): void;
            public setMaterial(material: zpp_nape.phys.ZPP_Material): void;
            public setFilter(filter: zpp_nape.dynamics.ZPP_InteractionFilter): void;
            public setFluid(fluid: zpp_nape.phys.ZPP_FluidProperties): void;
            public __immutable_midstep(name: String): void;
            public addedToBody(): void;
            public removedFromBody(): void;
            public addedToSpace(): void;
            public removedFromSpace(): void;
            public copy(): nape.shape.Shape;
        }
        export class ZPP_Circle extends zpp_nape.shape.ZPP_Shape {
            public outer_zn: nape.shape.Circle;
            public radius: number;
            public __validate_aabb: () => void;
            public _force_validate_aabb: () => void;
            public __clear(): void;
            public invalidate_radius(): void;
            public setupLocalCOM(): void;
            public __validate_sweepRadius(): void;
            public __validate_area_inertia(): void;
            public __validate_angDrag(): void;
            public __scale(sx: number, sy: number): void;
            public __translate(x: number, y: number): void;
            public __rotate(x: number, y: number): void;
            public __transform(m: nape.geom.Mat23): void;
            public __copy(): zpp_nape.shape.ZPP_Circle;
            constructor();
        }
        export class ZPP_Edge {
            public next: zpp_nape.shape.ZPP_Edge;
            public free: () => void;
            public alloc: () => void;
            public polygon: zpp_nape.shape.ZPP_Polygon;
            public outer: nape.shape.Edge;
            public lnormx: number;
            public lnormy: number;
            public wrap_lnorm: nape.geom.Vec2;
            public gnormx: number;
            public gnormy: number;
            public wrap_gnorm: nape.geom.Vec2;
            public length: number;
            public lprojection: number;
            public gprojection: number;
            public lp0: zpp_nape.geom.ZPP_Vec2;
            public gp0: zpp_nape.geom.ZPP_Vec2;
            public lp1: zpp_nape.geom.ZPP_Vec2;
            public gp1: zpp_nape.geom.ZPP_Vec2;
            public tp0: number;
            public tp1: number;
            public static zpp_pool: zpp_nape.shape.ZPP_Edge;
            public static internal: boolean;
            public wrapper(): nape.shape.Edge;
            public getlnorm(): void;
            public getgnorm(): void;
            constructor();
        }
        export class ZPP_Polygon extends zpp_nape.shape.ZPP_Shape {
            public outer_zn: nape.shape.Polygon;
            public lverts: zpp_nape.geom.ZPP_Vec2;
            public wrap_lverts: nape.geom.Vec2List;
            public gverts: zpp_nape.geom.ZPP_Vec2;
            public wrap_gverts: nape.geom.Vec2List;
            public edges: zpp_nape.util.ZNPList_ZPP_Edge;
            public wrap_edges: nape.shape.EdgeList;
            public edgeCnt: number;
            public reverse_flag: boolean;
            public zip_lverts: boolean;
            public zip_laxi: boolean;
            public zip_gverts: boolean;
            public zip_gaxi: boolean;
            public zip_valid: boolean;
            public validation: nape.shape.ValidationResult;
            public zip_sanitation: boolean;
            public splice_collinear: () => void;
            public validate_gverts: () => void;
            public validate_gaxi: () => void;
            public __validate_aabb: () => void;
            public _force_validate_aabb: () => void;
            public __validate_localCOM: () => void;
            public __clear(): void;
            public getlverts(): void;
            public getgverts(): void;
            public getedges(): void;
            public invalidate_lverts(): void;
            public invalidate_laxi(): void;
            public invalidate_gverts(): void;
            public invalidate_gaxi(): void;
            public valid(): nape.shape.ValidationResult;
            public validate_lverts(): void;
            public cleanup_lvert(x: zpp_nape.geom.ZPP_Vec2): void;
            public splice_collinear_real(): void;
            public reverse_vertices(): void;
            public validate_laxi(): void;
            public __validate_sweepRadius(): void;
            public __validate_area_inertia(): void;
            public __validate_angDrag(): void;
            public setupLocalCOM(): void;
            public __translate(dx: number, dy: number): void;
            public __scale(sx: number, sy: number): void;
            public __rotate(ax: number, ay: number): void;
            public __transform(mat: nape.geom.Mat23): void;
            public __copy(): zpp_nape.shape.ZPP_Polygon;
            constructor();
        }
    }
    export module space {
        export class ZPP_Broadphase {
            public space: zpp_nape.space.ZPP_Space;
            public is_sweep: boolean;
            public sweep: zpp_nape.space.ZPP_SweepPhase;
            public dynab: zpp_nape.space.ZPP_DynAABBPhase;
            public aabbShape: nape.shape.Shape;
            public matrix: nape.geom.Mat23;
            public circShape: nape.shape.Shape;
            public insert(shape: zpp_nape.shape.ZPP_Shape): void;
            public remove(shape: zpp_nape.shape.ZPP_Shape): void;
            public sync(shape: zpp_nape.shape.ZPP_Shape): void;
            public broadphase(space: zpp_nape.space.ZPP_Space, discrete: boolean): void;
            public clear(): void;
            public shapesUnderPoint(x: number, y: number, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesUnderPoint(x: number, y: number, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public updateAABBShape(aabb: zpp_nape.geom.ZPP_AABB): void;
            public shapesInAABB(aabb: zpp_nape.geom.ZPP_AABB, strict: boolean, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInAABB(aabb: zpp_nape.geom.ZPP_AABB, strict: boolean, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public updateCircShape(x: number, y: number, r: number): void;
            public shapesInCircle(x: number, y: number, r: number, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInCircle(x: number, y: number, r: number, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public validateShape(s: zpp_nape.shape.ZPP_Shape): void;
            public shapesInShape(shape: zpp_nape.shape.ZPP_Shape, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInShape(shape: zpp_nape.shape.ZPP_Shape, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public rayCast(ray: zpp_nape.geom.ZPP_Ray, inner: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter): nape.geom.RayResult;
            public rayMultiCast(ray: zpp_nape.geom.ZPP_Ray, inner: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.geom.RayResultList): nape.geom.RayResultList;
            constructor();
        }
        export class ZPP_AABBNode {
            public aabb: zpp_nape.geom.ZPP_AABB;
            public shape: zpp_nape.shape.ZPP_Shape;
            public dyn: boolean;
            public parent: zpp_nape.space.ZPP_AABBNode;
            public child1: zpp_nape.space.ZPP_AABBNode;
            public child2: zpp_nape.space.ZPP_AABBNode;
            public height: number;
            public rayt: number;
            public next: zpp_nape.space.ZPP_AABBNode;
            public alloc: () => void;
            public free: () => void;
            public mnext: zpp_nape.space.ZPP_AABBNode;
            public moved: boolean;
            public snext: zpp_nape.space.ZPP_AABBNode;
            public synced: boolean;
            public first_sync: boolean;
            public isLeaf: () => boolean;
            public static zpp_pool: zpp_nape.space.ZPP_AABBNode;
            constructor();
        }
        export class ZPP_AABBPair {
            public n1: zpp_nape.space.ZPP_AABBNode;
            public n2: zpp_nape.space.ZPP_AABBNode;
            public first: boolean;
            public sleeping: boolean;
            public id: number;
            public di: number;
            public arb: zpp_nape.dynamics.ZPP_Arbiter;
            public next: zpp_nape.space.ZPP_AABBPair;
            public alloc: () => void;
            public free: () => void;
            public static zpp_pool: zpp_nape.space.ZPP_AABBPair;
            constructor();
        }
        export class ZPP_AABBTree {
            public root: zpp_nape.space.ZPP_AABBNode;
            public inlined_insertLeaf: (leaf: zpp_nape.space.ZPP_AABBNode) => void;
            public inlined_removeLeaf: (leaf: zpp_nape.space.ZPP_AABBNode) => void;
            public balance: (a: zpp_nape.space.ZPP_AABBNode) => zpp_nape.space.ZPP_AABBNode;
            public static tmpaabb: zpp_nape.geom.ZPP_AABB;
            public clear(): void;
            public removeLeaf(leaf: zpp_nape.space.ZPP_AABBNode): void;
            constructor();
        }
        export class ZPP_DynAABBPhase extends zpp_nape.space.ZPP_Broadphase {
            public stree: zpp_nape.space.ZPP_AABBTree;
            public dtree: zpp_nape.space.ZPP_AABBTree;
            public pairs: zpp_nape.space.ZPP_AABBPair;
            public syncs: zpp_nape.space.ZPP_AABBNode;
            public moves: zpp_nape.space.ZPP_AABBNode;
            public dyn: (shape: zpp_nape.shape.ZPP_Shape) => boolean;
            public __sync: (shape: zpp_nape.shape.ZPP_Shape) => void;
            public treeStack2: zpp_nape.util.ZNPList_ZPP_AABBNode;
            public failed: nape.phys.BodyList;
            public openlist: zpp_nape.util.ZNPList_ZPP_AABBNode;
            public __insert(shape: zpp_nape.shape.ZPP_Shape): void;
            public __remove(shape: zpp_nape.shape.ZPP_Shape): void;
            public sync_broadphase(): void;
            public broadphase(space: zpp_nape.space.ZPP_Space, discrete: boolean): void;
            public clear(): void;
            public shapesUnderPoint(x: number, y: number, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesUnderPoint(x: number, y: number, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInAABB(aabb: zpp_nape.geom.ZPP_AABB, strict: boolean, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInAABB(aabb: zpp_nape.geom.ZPP_AABB, strict: boolean, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInCircle(x: number, y: number, r: number, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInCircle(x: number, y: number, r: number, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInShape(shp: zpp_nape.shape.ZPP_Shape, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInShape(shp: zpp_nape.shape.ZPP_Shape, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public rayCast(ray: zpp_nape.geom.ZPP_Ray, inner: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter): nape.geom.RayResult;
            public rayMultiCast(ray: zpp_nape.geom.ZPP_Ray, inner: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.geom.RayResultList): nape.geom.RayResultList;
            constructor(space: zpp_nape.space.ZPP_Space);
        }
        export class ZPP_Island {
            public next: zpp_nape.space.ZPP_Island;
            public elem: () => zpp_nape.space.ZPP_Island;
            public begin: () => zpp_nape.space.ZPP_Island;
            public _inuse: boolean;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.space.ZPP_Island) => void;
            public inlined_add: (o: zpp_nape.space.ZPP_Island) => zpp_nape.space.ZPP_Island;
            public inlined_insert: (cur: zpp_nape.space.ZPP_Island, o: zpp_nape.space.ZPP_Island) => zpp_nape.space.ZPP_Island;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.space.ZPP_Island;
            public inlined_remove: (obj: zpp_nape.space.ZPP_Island) => void;
            public inlined_try_remove: (obj: zpp_nape.space.ZPP_Island) => boolean;
            public inlined_erase: (pre: zpp_nape.space.ZPP_Island) => zpp_nape.space.ZPP_Island;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.space.ZPP_Island) => boolean;
            public front: () => zpp_nape.space.ZPP_Island;
            public comps: zpp_nape.util.ZNPList_ZPP_Component;
            public sleep: boolean;
            public waket: number;
            public free: () => void;
            public alloc: () => void;
            public static zpp_pool: zpp_nape.space.ZPP_Island;
            public add(o: zpp_nape.space.ZPP_Island): zpp_nape.space.ZPP_Island;
            public addAll(x: zpp_nape.space.ZPP_Island): void;
            public insert(cur: zpp_nape.space.ZPP_Island, o: zpp_nape.space.ZPP_Island): zpp_nape.space.ZPP_Island;
            public pop(): void;
            public pop_unsafe(): zpp_nape.space.ZPP_Island;
            public remove(obj: zpp_nape.space.ZPP_Island): void;
            public try_remove(obj: zpp_nape.space.ZPP_Island): boolean;
            public erase(pre: zpp_nape.space.ZPP_Island): zpp_nape.space.ZPP_Island;
            public splice(pre: zpp_nape.space.ZPP_Island, n: number): zpp_nape.space.ZPP_Island;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.space.ZPP_Island): boolean;
            public back(): zpp_nape.space.ZPP_Island;
            public iterator_at(ind: number): zpp_nape.space.ZPP_Island;
            public at(ind: number): zpp_nape.space.ZPP_Island;
            constructor();
        }
        export class ZPP_Component {
            public next: zpp_nape.space.ZPP_Component;
            public parent: zpp_nape.space.ZPP_Component;
            public rank: number;
            public isBody: boolean;
            public body: zpp_nape.phys.ZPP_Body;
            public constraint: zpp_nape.constraint.ZPP_Constraint;
            public island: zpp_nape.space.ZPP_Island;
            public sleeping: boolean;
            public waket: number;
            public woken: boolean;
            public free: () => void;
            public alloc: () => void;
            public reset: () => void;
            public static zpp_pool: zpp_nape.space.ZPP_Component;
            constructor();
        }
        export class ZPP_CallbackSet {
            public id: number;
            public di: number;
            public int1: zpp_nape.phys.ZPP_Interactor;
            public int2: zpp_nape.phys.ZPP_Interactor;
            public arbiters: zpp_nape.util.ZNPList_ZPP_Arbiter;
            public COLLISIONstate: number;
            public COLLISIONstamp: number;
            public SENSORstate: number;
            public SENSORstamp: number;
            public FLUIDstate: number;
            public FLUIDstamp: number;
            public next: zpp_nape.space.ZPP_CallbackSet;
            public elem: () => zpp_nape.space.ZPP_CallbackSet;
            public begin: () => zpp_nape.space.ZPP_CallbackSet;
            public _inuse: boolean;
            public modified: boolean;
            public pushmod: boolean;
            public length: number;
            public setbegin: (i: zpp_nape.space.ZPP_CallbackSet) => void;
            public inlined_add: (o: zpp_nape.space.ZPP_CallbackSet) => zpp_nape.space.ZPP_CallbackSet;
            public inlined_insert: (cur: zpp_nape.space.ZPP_CallbackSet, o: zpp_nape.space.ZPP_CallbackSet) => zpp_nape.space.ZPP_CallbackSet;
            public inlined_pop: () => void;
            public inlined_pop_unsafe: () => zpp_nape.space.ZPP_CallbackSet;
            public inlined_remove: (obj: zpp_nape.space.ZPP_CallbackSet) => void;
            public inlined_try_remove: (obj: zpp_nape.space.ZPP_CallbackSet) => boolean;
            public inlined_erase: (pre: zpp_nape.space.ZPP_CallbackSet) => zpp_nape.space.ZPP_CallbackSet;
            public inlined_clear: () => void;
            public empty: () => boolean;
            public size: () => number;
            public inlined_has: (obj: zpp_nape.space.ZPP_CallbackSet) => boolean;
            public front: () => zpp_nape.space.ZPP_CallbackSet;
            public freed: boolean;
            public lazydel: boolean;
            public free: () => void;
            public alloc: () => void;
            public add_arb: (x: zpp_nape.dynamics.ZPP_Arbiter) => boolean;
            public really_empty: () => boolean;
            public sleeping: () => boolean;
            public static zpp_pool: zpp_nape.space.ZPP_CallbackSet;
            public static get(i1: zpp_nape.phys.ZPP_Interactor, i2: zpp_nape.phys.ZPP_Interactor): zpp_nape.space.ZPP_CallbackSet;
            public add(o: zpp_nape.space.ZPP_CallbackSet): zpp_nape.space.ZPP_CallbackSet;
            public addAll(x: zpp_nape.space.ZPP_CallbackSet): void;
            public insert(cur: zpp_nape.space.ZPP_CallbackSet, o: zpp_nape.space.ZPP_CallbackSet): zpp_nape.space.ZPP_CallbackSet;
            public pop(): void;
            public pop_unsafe(): zpp_nape.space.ZPP_CallbackSet;
            public remove(obj: zpp_nape.space.ZPP_CallbackSet): void;
            public try_remove(obj: zpp_nape.space.ZPP_CallbackSet): boolean;
            public erase(pre: zpp_nape.space.ZPP_CallbackSet): zpp_nape.space.ZPP_CallbackSet;
            public splice(pre: zpp_nape.space.ZPP_CallbackSet, n: number): zpp_nape.space.ZPP_CallbackSet;
            public clear(): void;
            public reverse(): void;
            public has(obj: zpp_nape.space.ZPP_CallbackSet): boolean;
            public back(): zpp_nape.space.ZPP_CallbackSet;
            public iterator_at(ind: number): zpp_nape.space.ZPP_CallbackSet;
            public at(ind: number): zpp_nape.space.ZPP_CallbackSet;
            public try_remove_arb(x: zpp_nape.dynamics.ZPP_Arbiter): boolean;
            public remove_arb(x: zpp_nape.dynamics.ZPP_Arbiter): void;
            public empty_arb(type: number): boolean;
            constructor();
        }
        export class ZPP_CbSetManager {
            public cbsets: zpp_nape.util.ZPP_Set_ZPP_CbSet;
            public space: zpp_nape.space.ZPP_Space;
            public validate: () => void;
            public pair: (a: zpp_nape.callbacks.ZPP_CbSet, b: zpp_nape.callbacks.ZPP_CbSet) => zpp_nape.callbacks.ZPP_CbSetPair;
            public valid_listener: (i: zpp_nape.callbacks.ZPP_Listener) => boolean;
            public get(cbTypes: zpp_nape.util.ZNPList_ZPP_CbType): zpp_nape.callbacks.ZPP_CbSet;
            public remove(set: zpp_nape.callbacks.ZPP_CbSet): void;
            public clear(): void;
            constructor(space: zpp_nape.space.ZPP_Space);
        }
        export class ZPP_Space {
            public outer: nape.space.Space;
            public userData: any;
            public gravityx: number;
            public gravityy: number;
            public wrap_gravity: nape.geom.Vec2;
            public bodies: zpp_nape.util.ZNPList_ZPP_Body;
            public wrap_bodies: nape.phys.BodyList;
            public compounds: zpp_nape.util.ZNPList_ZPP_Compound;
            public wrap_compounds: nape.phys.CompoundList;
            public constraints: zpp_nape.util.ZNPList_ZPP_Constraint;
            public wrap_constraints: nape.constraint.ConstraintList;
            public kinematics: zpp_nape.util.ZNPList_ZPP_Body;
            public bphase: zpp_nape.space.ZPP_Broadphase;
            public __static: nape.phys.Body;
            public global_lin_drag: number;
            public global_ang_drag: number;
            public stamp: number;
            public midstep: boolean;
            public time: number;
            public sortcontacts: boolean;
            public c_arbiters_true: zpp_nape.util.ZNPList_ZPP_ColArbiter;
            public c_arbiters_false: zpp_nape.util.ZNPList_ZPP_ColArbiter;
            public f_arbiters: zpp_nape.util.ZNPList_ZPP_FluidArbiter;
            public s_arbiters: zpp_nape.util.ZNPList_ZPP_SensorArbiter;
            public wrap_arbiters: nape.dynamics.ArbiterList;
            public live: zpp_nape.util.ZNPList_ZPP_Body;
            public wrap_live: nape.phys.BodyList;
            public live_constraints: zpp_nape.util.ZNPList_ZPP_Constraint;
            public wrap_livecon: nape.constraint.ConstraintList;
            public staticsleep: zpp_nape.util.ZNPList_ZPP_Body;
            public islands: zpp_nape.space.ZPP_Island;
            public listeners: zpp_nape.util.ZNPList_ZPP_Listener;
            public wrap_listeners: nape.callbacks.ListenerList;
            public callbacks: zpp_nape.callbacks.ZPP_Callback;
            public callbackset_list: zpp_nape.space.ZPP_CallbackSet;
            public cbsets: zpp_nape.space.ZPP_CbSetManager;
            public revoke_listener: (x: zpp_nape.callbacks.ZPP_InteractionListener) => void;
            public unrevoke_listener: (x: zpp_nape.callbacks.ZPP_InteractionListener) => void;
            public added_shape: (s: zpp_nape.shape.ZPP_Shape, dontwake?: boolean) => void;
            public pre_dt: number;
            public toiEvents: zpp_nape.util.ZNPList_ZPP_ToiEvent;
            public continuous: boolean;
            public group_ignore: (s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape) => boolean;
            public interactionType: (s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, b1: zpp_nape.phys.ZPP_Body, b2: zpp_nape.phys.ZPP_Body) => number;
            public mrca1: zpp_nape.util.ZNPList_ZPP_Interactor;
            public mrca2: zpp_nape.util.ZNPList_ZPP_Interactor;
            public inlined_MRCA_chains: (s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape) => void;
            public getgravity(): void;
            public clear(): void;
            public addListener(x: zpp_nape.callbacks.ZPP_Listener): void;
            public remListener(x: zpp_nape.callbacks.ZPP_Listener): void;
            public add_callbackset(cb: zpp_nape.space.ZPP_CallbackSet): void;
            public remove_callbackset(cb: zpp_nape.space.ZPP_CallbackSet): void;
            public transmitType(p: zpp_nape.phys.ZPP_Body, new_type: number): void;
            public removed_shape(s: zpp_nape.shape.ZPP_Shape, deleting?: boolean): void;
            public addConstraint(con: zpp_nape.constraint.ZPP_Constraint): void;
            public remConstraint(con: zpp_nape.constraint.ZPP_Constraint): void;
            public addCompound(x: zpp_nape.phys.ZPP_Compound): void;
            public remCompound(x: zpp_nape.phys.ZPP_Compound): void;
            public addBody(body: zpp_nape.phys.ZPP_Body, flag?: number): void;
            public remBody(body: zpp_nape.phys.ZPP_Body, flag?: number): void;
            public shapesUnderPoint(x: number, y: number, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesUnderPoint(x: number, y: number, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInAABB(aabb: nape.geom.AABB, strict: boolean, cont: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInAABB(aabb: nape.geom.AABB, strict: boolean, cont: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInCircle(pos: nape.geom.Vec2, rad: number, cont: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInCircle(pos: nape.geom.Vec2, rad: number, cont: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInShape(shape: zpp_nape.shape.ZPP_Shape, cont: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInShape(shape: zpp_nape.shape.ZPP_Shape, cont: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public rayCast(ray: nape.geom.Ray, inner: boolean, filter: nape.dynamics.InteractionFilter): nape.geom.RayResult;
            public rayMultiCast(ray: nape.geom.Ray, inner: boolean, filter: nape.dynamics.InteractionFilter, output: nape.geom.RayResultList): nape.geom.RayResultList;
            public convexCast(shape: zpp_nape.shape.ZPP_Shape, deltaTime: number, filter: nape.dynamics.InteractionFilter, dynamics: boolean): nape.geom.ConvexResult;
            public convexMultiCast(shape: zpp_nape.shape.ZPP_Shape, deltaTime: number, filter: nape.dynamics.InteractionFilter, dynamics: boolean, output: nape.geom.ConvexResultList): nape.geom.ConvexResultList;
            public push_callback(i: zpp_nape.callbacks.ZPP_Listener): zpp_nape.callbacks.ZPP_Callback;
            public step(deltaTime: number, velocityIterations: number, positionIterations: number): void;
            public continuousCollisions(deltaTime: number): void;
            public continuousEvent(s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, stat: boolean, in_arb: zpp_nape.dynamics.ZPP_Arbiter, _: boolean): zpp_nape.dynamics.ZPP_Arbiter;
            public bodyCbWake(b: zpp_nape.phys.ZPP_Body): void;
            public bodyCbSleep(b: zpp_nape.phys.ZPP_Body): void;
            public constraintCbWake(con: zpp_nape.constraint.ZPP_Constraint): void;
            public constraintCbSleep(con: zpp_nape.constraint.ZPP_Constraint): void;
            public constraintCbBreak(con: zpp_nape.constraint.ZPP_Constraint): void;
            public nullListenerType(cb1: zpp_nape.callbacks.ZPP_CbSet, cb2: zpp_nape.callbacks.ZPP_CbSet): void;
            public nullInteractorType(intx: zpp_nape.phys.ZPP_Interactor, me?: zpp_nape.phys.ZPP_Interactor): void;
            public freshListenerType(cb1: zpp_nape.callbacks.ZPP_CbSet, cb2: zpp_nape.callbacks.ZPP_CbSet): void;
            public freshInteractorType(intx: zpp_nape.phys.ZPP_Interactor, me?: zpp_nape.phys.ZPP_Interactor): void;
            public wakeCompound(x: zpp_nape.phys.ZPP_Compound): void;
            public wakeIsland(i: zpp_nape.space.ZPP_Island): void;
            public non_inlined_wake(o: zpp_nape.phys.ZPP_Body, fst?: boolean): void;
            public really_wake(o: zpp_nape.phys.ZPP_Body, fst?: boolean): void;
            public wake_constraint(con: zpp_nape.constraint.ZPP_Constraint, fst?: boolean): boolean;
            public doForests(dt: number): void;
            public sleepArbiters(): void;
            public static_validation(body: zpp_nape.phys.ZPP_Body): void;
            public validation(): void;
            public updateVel(dt: number): void;
            public updatePos(dt: number): void;
            public presteparb(arb: zpp_nape.dynamics.ZPP_Arbiter, dt: number, cont?: boolean): boolean;
            public prestep(dt: number): void;
            public warmStart(): void;
            public iterateVel(times: number): void;
            public iteratePos(times: number): void;
            public narrowPhase(s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape, stat: boolean, in_arb: zpp_nape.dynamics.ZPP_Arbiter, continuous: boolean): zpp_nape.dynamics.ZPP_Arbiter;
            public MRCA_chains(s1: zpp_nape.shape.ZPP_Shape, s2: zpp_nape.shape.ZPP_Shape): void;
            constructor(gravity: zpp_nape.geom.ZPP_Vec2, broadphase: nape.space.Broadphase);
        }
        export class ZPP_SweepData {
            public next: zpp_nape.space.ZPP_SweepData;
            public prev: zpp_nape.space.ZPP_SweepData;
            public shape: zpp_nape.shape.ZPP_Shape;
            public aabb: zpp_nape.geom.ZPP_AABB;
            public free: () => void;
            public alloc: () => void;
            public gt: (x: zpp_nape.space.ZPP_SweepData) => boolean;
            public static zpp_pool: zpp_nape.space.ZPP_SweepData;
            constructor();
        }
        export class ZPP_SweepPhase extends zpp_nape.space.ZPP_Broadphase {
            public list: zpp_nape.space.ZPP_SweepData;
            public __sync: (shape: zpp_nape.shape.ZPP_Shape) => void;
            public sync_broadphase_fast: () => void;
            public failed: nape.phys.BodyList;
            public __insert(shape: zpp_nape.shape.ZPP_Shape): void;
            public __remove(shape: zpp_nape.shape.ZPP_Shape): void;
            public sync_broadphase(): void;
            public broadphase(space: zpp_nape.space.ZPP_Space, discrete: boolean): void;
            public clear(): void;
            public shapesUnderPoint(x: number, y: number, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesUnderPoint(x: number, y: number, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInAABB(aabb: zpp_nape.geom.ZPP_AABB, strict: boolean, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInAABB(aabb: zpp_nape.geom.ZPP_AABB, strict: boolean, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInCircle(x: number, y: number, r: number, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInCircle(x: number, y: number, r: number, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public shapesInShape(shape: zpp_nape.shape.ZPP_Shape, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.shape.ShapeList): nape.shape.ShapeList;
            public bodiesInShape(shape: zpp_nape.shape.ZPP_Shape, containment: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.phys.BodyList): nape.phys.BodyList;
            public rayCast(ray: zpp_nape.geom.ZPP_Ray, inner: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter): nape.geom.RayResult;
            public rayMultiCast(ray: zpp_nape.geom.ZPP_Ray, inner: boolean, filter: zpp_nape.dynamics.ZPP_InteractionFilter, output: nape.geom.RayResultList): nape.geom.RayResultList;
            constructor(space: zpp_nape.space.ZPP_Space);
        }
    }
    export class ZPP_Const {
        public static POSINF: () => number;
        public static NEGINF: () => number;
        public static FMAX: number;
    }
    export class ZPP_ID {
        public static _Constraint: number;
        public static _Interactor: number;
        public static _CbType: number;
        public static _CbSet: number;
        public static _Listener: number;
        public static _ZPP_SimpleVert: number;
        public static _ZPP_SimpleSeg: number;
        public static _Space: number;
        public static _InteractionGroup: number;
        public static Constraint(): number;
        public static Interactor(): number;
        public static CbType(): number;
        public static CbSet(): number;
        public static Listener(): number;
        public static ZPP_SimpleVert(): number;
        public static ZPP_SimpleSeg(): number;
        public static Space(): number;
        public static InteractionGroup(): number;
    }
}
